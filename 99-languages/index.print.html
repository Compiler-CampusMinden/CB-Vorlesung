<!DOCTYPE html>
<html lang="de-DE" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.135.0">
    <meta name="generator" content="Relearn 6.4.1">
    <meta name="description" content="Unterschiedliche Programmiersprachen weisen nicht nur verschiedene Syntaxelemente auf, sondern haben eine teilweise stark unterschiedliche Semantik. Beides hat Auswirkungen auf die Bausteine eines Compilers.
Einführung in C&#43;&#43; (Erinnerungen an C) C&#43;&#43;: Pointer und Referenzen C&#43;&#43;: Klassen C&#43;&#43;: Big 3 C&#43;&#43;: Operatoren C&#43;&#43;: Vererbung und Polymorphie C&#43;&#43;: Templates">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Programmiersprachen und -konzepte">
    <meta name="twitter:description" content="Unterschiedliche Programmiersprachen weisen nicht nur verschiedene Syntaxelemente auf, sondern haben eine teilweise stark unterschiedliche Semantik. Beides hat Auswirkungen auf die Bausteine eines Compilers.
Einführung in C&#43;&#43; (Erinnerungen an C) C&#43;&#43;: Pointer und Referenzen C&#43;&#43;: Klassen C&#43;&#43;: Big 3 C&#43;&#43;: Operatoren C&#43;&#43;: Vererbung und Polymorphie C&#43;&#43;: Templates">
    <meta property="og:url" content="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages.html">
    <meta property="og:title" content="Programmiersprachen und -konzepte">
    <meta property="og:description" content="Unterschiedliche Programmiersprachen weisen nicht nur verschiedene Syntaxelemente auf, sondern haben eine teilweise stark unterschiedliche Semantik. Beides hat Auswirkungen auf die Bausteine eines Compilers.
Einführung in C&#43;&#43; (Erinnerungen an C) C&#43;&#43;: Pointer und Referenzen C&#43;&#43;: Klassen C&#43;&#43;: Big 3 C&#43;&#43;: Operatoren C&#43;&#43;: Vererbung und Polymorphie C&#43;&#43;: Templates">
    <meta property="og:locale" content="de_DE">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Programmiersprachen und -konzepte">
    <meta itemprop="description" content="Unterschiedliche Programmiersprachen weisen nicht nur verschiedene Syntaxelemente auf, sondern haben eine teilweise stark unterschiedliche Semantik. Beides hat Auswirkungen auf die Bausteine eines Compilers.
Einführung in C&#43;&#43; (Erinnerungen an C) C&#43;&#43;: Pointer und Referenzen C&#43;&#43;: Klassen C&#43;&#43;: Big 3 C&#43;&#43;: Operatoren C&#43;&#43;: Vererbung und Polymorphie C&#43;&#43;: Templates">
    <meta itemprop="wordCount" content="46">
    <title>Programmiersprachen und -konzepte</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages.html" rel="canonical" type="text/html" title="Programmiersprachen und -konzepte">

    

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/images/logo.png?1739788418" rel="icon" type="image/png">

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fontawesome-all.min.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fontawesome-all.min.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/nucleus.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/auto-complete.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/auto-complete.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/perfect-scrollbar.min.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fonts.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fonts.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/theme.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/theme-auto.css?1739788418" rel="stylesheet" id="R-variant-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/chroma-auto.css?1739788418" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/variant.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/print.css?1739788418" rel="stylesheet" media="print">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/format-print.css?1739788418" rel="stylesheet">
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/variant.js?1739788418"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='.';
      window.relearn.relBaseUri='..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1360443';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.index_js_url="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/index.search.js?1739788418";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Programmiersprachen und -konzepte
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="programmiersprachen-und--konzepte">Programmiersprachen und -konzepte</h1>

<p>Unterschiedliche Programmiersprachen weisen nicht nur verschiedene Syntaxelemente auf,
sondern haben eine teilweise stark unterschiedliche Semantik. Beides hat Auswirkungen
auf die Bausteine eines Compilers.</p>
<ul class="children children-li children-sort-">
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp0-basics.html">Einführung in C&#43;&#43; (Erinnerungen an C)</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp1-pointer.html">C&#43;&#43;: Pointer und Referenzen</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp2-classes.html">C&#43;&#43;: Klassen</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp3-big3.html">C&#43;&#43;: Big 3</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp4-operators.html">C&#43;&#43;: Operatoren</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance.html">C&#43;&#43;: Vererbung und Polymorphie</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp6-templates.html">C&#43;&#43;: Templates</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Programmiersprachen und -konzepte</h1>
<article class="default">
<h1>Einführung in C&#43;&#43; (Erinnerungen an C)</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Für C wurde ein paar Jahre nach der Entstehung ein objektorientierter Aufsatz entwickelt: C++.
Beide Sprachversionen werden aktiv weiterentwickelt, vor allem in C++ gibt es ca. alle 3 Jahre
einen neuen Standard mit teilweise recht umfangreichen Ergänzungen. Hier fließen analog zu Java
immer mehr Programmierkonzepte mit ein, die aus anderen Sprachen stammen (etwa funktionale
Programmierung). Das macht das Erlernen und Beherrschen der Sprache nicht unbedingt leichter.
Die für uns wichtigsten Neuerungen kamen mit C11 und C++11 bzw. C++14.</p>
<p>C und C++ versuchen (im Gegensatz zu Java) ressourcenschonende Sprachen zu sein: Ein korrektes
Programm soll so schnell wie möglich ausgeführt werden können und dabei so effizient wie möglich
sein (etwa in Bezug auf den Speicherbedarf). Deshalb gibt es keine Laufzeitumgebung, der Quellcode
wird direkt in ein ausführbares (und damit Betriebssystem-abhängiges) Binary compiliert. Beide
Sprachen erlauben dem Programmierer den Zugriff auf die Speicherverwaltung und damit viele Freiheiten.
Die Kehrseite ist natürlich, dass Programmierfehler (etwa bei der Speicherallokation oder bei
Indexberechnungen) nicht von der Laufzeitumgebung entdeckt und abgefangen werden können.</p>
<p>C-Programme sehen auf den ersten Blick Java-Code relativ ähnlich. Das ist nicht verwunderlich,
da Java zeitlich nach C/C++ entwickelt wurde und die Syntax und große Teile der Schlüsselwörter
von C und C++ übernommen hat. C++ hat die C-Syntax übernommen und fügt neue objektorientierte
Konzepte hinzu. Mit gewissen Einschränkungen funktioniert also C-Code auch in C++.</p>
<p>In C++ gibt es Klassen (mit Methoden und Attributen), und zusätzlich gibt es Funktionen. Der
Einsprungpunkt in ein Programm ist (analog zu Java) die Funktion <code>main()</code>, die ein <code>int</code> als
Ergebnis zurückliefert. Dieser Integer kann vom Aufrufer ausgewertet werden, wobei der Wert 0
typischerweise als Erfolg interpretiert wird. Achtung: Das ist eine <em>Konvention</em>, d.h. es kann
Programme geben, die andere Werte zurückliefern. Die Werte müssen dokumentiert werden.</p>
<p>Bevor der Compiler den Quelltext &quot;sieht&quot;, wird dieser von einem Präprozessor bearbeitet. Dieser
hat verschiedene Aufgaben, unter anderem das Einbinden anderer Dateien. Dabei wird ein
<code>#include &quot;dateiname&quot;</code> (sucht im aktuellen Ordner) bzw. <code>#include &lt;dateiname&gt;</code> (sucht im
Standardverzeichnis) ersetzt durch den Inhalt der angegebenen Datei.</p>
<p>C++-Code muss kompiliert werden. Dabei entsteht ein ausführbares Programm. Mit Make kann man den
Kompiliervorgang über Regeln automatisieren (denken Sie an ANT in der Java-Welt, nur ohne XML).
Eine Regel besteht aus einem Ziel (<em>Target</em>), einer Liste von Abhängigkeiten sowie einer Liste mit
Aktionen (Anweisungen). Um ein Ziel zu &quot;bauen&quot; müssen zunächst alle Abhängigkeiten erfüllt sein
(bzw. falls sie es nicht sind, erst noch &quot;gebaut&quot; werden - es muss entsprechend weitere Regeln
geben, um diese Abhängigkeiten &quot;bauen&quot; zu können). Dann wird die Liste der Aktionen abgearbeitet.
Ziele und Abhängigkeiten sind in der Regel Namen von Dateien, die existieren müssen bzw. über die
Aktionen erzeugt werden sollen. Die Aktionen sind normale Befehlssequenzen, die man auch in einer
Konsole eingeben könnte. Make berücksichtigt den Zeitstempel der Dateien: Ziele, die bereits
existieren und deren Abhängigkeiten nicht neuer sind, werden nicht erneut gebaut.</p>
<p>Die gute Nachricht: In Bezug auf Variablen, Operatoren und Kontrollfluss verhalten sich C und C++
im Wesentlichen wie Java.</p>
<p>Es gibt in C++ den Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>. Zusätzlich werden Integerwerte
im boolschen Kontext (etwa in einer <code>if</code>-Abfrage) ausgewertet, wobei der Wert 0 einem <code>false</code>
entspricht und alle anderen Integer-Werte einem <code>true</code>. (Dies steht etwas im Widerspruch zu den
Werten, die in der <code>main</code>-Funktion per <code>return</code> zurückgeliefert werden: Hier bedeutet 0 in der
Regel, dass alles OK war.)</p>
<p>Die Basisdatentypen sind (bis auf <code>char</code> und <code>bool</code>) in ihrer Größe maschinenabhängig. Es kann
also sein, dass Code, der auf einem 64bit-Laptop ohne Probleme läuft, auf einem Raspberry PI
Überläufe verursacht! Um besonders ressourcenschonend zu arbeiten, kann man die Speichergröße
für einige Basisdatentypen durch die Typmodifikatoren <code>short</code> und <code>long</code> beeinflussen sowie
die Interpretation von Zahlenwerten mit oder ohne Vorzeichen (<code>signed</code>, <code>unsigned</code>) einstellen.</p>
<p>Die Anzahl der für einen Typ oder eine Variable/Struktur benötigten Bytes bekommt man mit
dem Operator <code>sizeof</code> heraus.</p>
<p>Mit <code>typedef</code> kann man einen neuen Namen für bereits existierende Typen vergeben.</p>
<p>In C++ gibt es Funktionen (analog zu Methoden in Java), diese existieren unabhängig von Klassen.</p>
<p>Wenn eine Funktion aufgerufen wird, muss dem Compiler die Signatur zur Prüfung bekannt sein. Das
bedeutet, dass die Funktion entweder zuvor komplett definiert werden muss oder zumindest zuvor
deklariert werden muss (die Definition kann auch später in der Datei kommen oder in einer anderen
Datei). Das Vorab-Deklarieren einer Funktion nennt man auch &quot;Funktionsprototypen&quot;.</p>
<p>Eine Deklaration darf (so lange sie konsistent ist) mehrfach vorkommen, eine Definition immer nur
exakt einmal. Dabei werden alle Code-Teile, die zu einem Programm zusammencompiliert werden,
gemeinsam betrachtet. =&gt; Das ist auch als <strong>One-Definition-Rule</strong> bekannt.</p>
<p>In C++ gilt beim Funktionsaufruf immer zunächst immer die Parameterübergabe per <strong>call-by-value</strong>
(dito bei der Rückgabe von Werten). Wenn Referenzen oder Pointer eingesetzt werden, wird dagegen
auch ein <em>call-by-reference</em> möglich. (Dazu später mehr.)</p>
<p>Unterscheidung in globale, lokale und lokale statische Variablen mit unterschiedlicher Lebensdauer
und unterschiedlicher Initialisierung durch den Compiler.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/b9xOaxc8Uus' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Einführung in C++ (Erinnerungen an C)</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K1) Wie hängen C und C++ zusammen?</li> <li>(K1) Wichtigste Unterschiede und Gemeinsamkeiten zu Java</li> <li>(K1) Wichtigste Aufgaben des Präprozessors</li> <li>(K3) Aufbau, Übersetzen und Starten von einfachen C++-Programmen</li> <li>(K3) Standard-Ein-/Ausgabe-Kanäle in C++ sowie die Operatoren <code>&gt;&gt;</code> und <code>&lt;&lt;</code></li> <li>(K3) Nutzung der Basisdatentypen einschließlich der Modifikatoren</li> <li>(K3) Deklaration von Variablen, Nutzung von Kontrollstrukturen und Operatoren</li> <li>(K3) Interpretation von Integers im booleschen Kontext</li> <li>(K3) Nutzung des Scope-Operators <code>::</code>, Namensräume</li> <li>(K3) Benutzung von <code>sizeof</code> zur Bestimmung des Speicherbedarfs</li> <li>(K3) Benutzung von <code>typedef</code> zur Definition neuer Typen (Aliase bestehender Typen)</li> <li>(K3) Erinnerung: Automatisiertes Übersetzen mit Hilfe von GNU Make und einfachsten Makefiles</li> <li>(K2) Unterschied zwischen Deklaration und Definition, One Definition Rule</li> <li>(K2) Problematik bei der Deklaration parameterloser Funktionen</li> <li>(K2) Call-by-Value-Semantik bei der Parameterübergabe</li> <li>(K2) Sichtbarkeit und Initialisierung von Variablen</li> <li>(K3) Definition und Deklaration von Funktionen</li> <li>(K3) Nutzung lokaler und globaler und lokaler statischer Variablen</li></ul>
  </div>
</div>




    <h2 id="warum">Warum?</h2>
<ul>
<li>C++ erlaubt ressourcenschonende Programmierung</li>
<li>Objektorientierter &quot;Aufsatz&quot; auf C</li>
<li>Verbreitet bei hardwarenaher und/oder rechenintensiver Software</li>
</ul>
<div class='center'>
<p><span class='alert'><strong>Sie werden C++ im Modul &quot;Computergrafik&quot; brauchen!</strong></span></p>
</div>
<p><strong>Geschichte</strong></p>
<ul>
<li>1971-73: <span class='alert'>Ritchie</span> entwickelt die Sprache <span class='alert'>C</span></li>
<li>Ab 1979: Entwicklung von <span class='alert'>C++</span> durch Bjarne <span class='alert'>Stroustrup</span> bei AT&amp;T
<ul>
<li>Erweiterung der prozeduralen Sprache C</li>
<li>Ursprünglich &quot;C mit Klassen&quot;, später &quot;C++&quot; (Inkrement-Operator)</li>
</ul>
</li>
<li>Bis heute: Fortlaufende Erweiterungen: alle 3 Jahre neuer Standard (C++11, C++14, ...)</li>
</ul>
<div class="box notices cstyle info">
  <div class="box-label">
    <i class="fa-fw fas fa-info-circle"></i> <strong>C/C++ vs. Java</strong>
  </div>
  <div class="box-content">
<ul>
<li>Java: Fokus auf Sicherheit und Robustheit
<ul>
<li>Diverse Sicherheitschecks durch Compiler und VM (zb. Array-Zugriff)</li>
<li>Speicherverwaltung (Garbage Collection), kein Speicherzugriff über Pointer</li>
<li>Automatische Initialisierung von Variablen</li>
</ul>
</li>
<li>C/C++: Fokus auf Effizienz (Speicher, Laufzeit) für korrekte Programme
<ul>
<li>Vergleichsweise schwache Sicherheitschecks durch Compiler, keine VM
(d.h. keine Prüfung von Array-Indizes u.a.)</li>
<li>Keine Garbage Collection, Programmierer hat direkten Zugriff auf Speicher</li>
<li>Keine automatische Initialisierung von Variablen</li>
</ul>
</li>
</ul>
  </div>
</div>
<h2 id="hello-world">Hello World!</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * HelloWorld.cpp (g++ -Wall HelloWorld.cpp)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Hello World from C++  :-)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World from C++  :-)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World from C++  :-)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="beobachtungen">Beobachtungen</h3>
<p>Jedes (ausführbare) C++-Programm hat genau eine <code>main()</code>-Funktion. Die <code>main()</code>-Funktion ist
<em>keine Methode</em> einer Klasse: In C/C++ gibt es Funktionen auch außerhalb von Klassen.</p>
<p>In C++ gibt es Namespaces (dazu später mehr). Die aus der Standardbibliothek importierten
Funktionen sind in der Regel im Namespace <code>std</code> definiert. Mit <code>using namespace std;</code> können
Sie auf die Elemente direkt zugreifen. Wenn Sie das <code>using namespace std;</code> weglassen, müssten
Sie bei jeder Verwendung eines Symbols den Namensraum explizit dazu schreiben
<code>std::cout &lt;&lt; &quot;Hello World from C++  :-)&quot; &lt;&lt; std::endl;</code>.</p>
<p>Sie können im C++-Code auch Funktionen aus C benutzen, d.h. Sie können für die Ausgabe
beispielsweise <code>printf</code> nutzen (dazu müssen Sie den Header <code>&lt;cstdio&gt;</code> importieren). Die
&quot;richtige&quot; Ausgabe in C++ ist aber die Nutzung des Ausgabestreams <code>cout</code> und des
Ausgabeoperators <code>&lt;&lt;</code>. Das <code>endl</code> sorgt für einen zum jeweiligen Betriebssystem passenden
Zeilenumbruch.</p>
<p>Der Rückgabewert signalisiert Erfolg bzw. Fehler der Programmausführung. Dabei steht der Wert
0 traditionell für Erfolg (Konvention!). Besser Makros nutzen: <code>EXIT_SUCCESS</code> bzw.
<code>EXIT_FAILURE</code> (in <code>cstdlib</code>).</p>
<h3 id="präprozessor">Präprozessor</h3>
<p>Der Präprozessor transformiert den Quellcode <em>vor</em> dem Compiler-Lauf. Zu den wichtigsten
Aufgaben gehören dabei die Makrosubstitution (<code>#define Makroname Ersatztext</code>) und das Einfügen
von Header-Dateien (und anderen Dateien) per <code>#include</code>. Es gibt dabei zwei Formen, die an
unterschiedlichen Orten nach der angegebenen Datei suchen:</p>
<ul>
<li><code>#include &quot;dateiname&quot;</code> sucht im aktuellen Ordner</li>
<li><code>#include &lt;dateiname&gt;</code> sucht im Standardverzeichnis</li>
</ul>
<p>Das <code>#include</code> kann wie in C genutzt werden, aber es gibt auch die Form ohne die Dateiendung
&quot;.h&quot;. Da es in C keine Funktionsüberladung gibt (in C++ dagegen schon), müssen die C-Header
speziell markiert sein, um sie in C++ verwenden zu können. Für die Standard-Header ist dies
bereits erledigt, Sie finden diese mit einem &quot;c&quot; vorangestellt:</p>
<ul>
<li>Include in C: <code>#include &lt;stdio.h&gt;</code></li>
<li>Include in C++: <code>#include &lt;cstdio&gt;</code></li>
</ul>
<h3 id="übersetzen-linken-ausführen">Übersetzen, Linken, Ausführen</h3>
<p>C++-Dateien werden üblicherweise mit der Endung &quot;<strong>.cpp</strong>&quot; oder &quot;.cxx&quot; oder &quot;.cc&quot;
abgespeichert, Header-Dateien mit den Endungen &quot;.hpp&quot; oder &quot;.hxx&quot; oder &quot;.hh&quot;.</p>
<p>Zum Übersetzen und Linken in einem Arbeitsschritt rufen Sie den Compiler auf:
<code>g++ HelloWorld.cpp</code> bzw. besser <strong><code>g++ -Wall -o helloworld HelloWorld.cpp</code></strong>. Die Option
<code>-Wall</code> sorgt dafür, dass alle Warnungen aktiviert werden.</p>
<p>Ausführen können Sie das erzeugte Programm in der Konsole mit: <code>./helloworld</code>. Der aktuelle
Ordner ist üblicherweise (aus Sicherheitsgründen) nicht im Suchpfad für ausführbare Dateien
enthalten. Deshalb muss man explizit angeben, dass ein Programm im aktuellen Ordner (<code>.</code>)
ausgeführt werden soll.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/HelloWorld.cpp" target="_blank"><span class="title">Konsole: HelloWorld.cpp</span></a></span></div>
<h2 id="variablen-operatoren-kontrollfluss">Variablen, Operatoren, Kontrollfluss</h2>
<div class='center'>
<p><span class='alert'><strong>Im Wesentlichen wie von C und Java gewohnt ... :-)</strong></span></p>
</div>
<ul>
<li>
<p>Wichtig(st)e Abweichung:</p>
<p>Im booleschen Kontext wird <code>int</code> als Wahrheitswert interpretiert:
Alle Werte ungleich 0 entsprechen <code>true</code> (!)</p>
<p><strong>Anmerkung</strong>: Dies steht im Widerspruch zu den Werten, die in der <code>main</code>-Funktion per
<code>return</code> zurückgeliefert werden: Hier bedeutet 0 in der Regel, dass alles OK war.</p>
</li>
</ul>
<p>=&gt; Vorsicht mit</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> c;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (c<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>) { ... }</span></span></code></pre></div>
<h2 id="ein--und-ausgabe-mit-printf-und-cincout">Ein- und Ausgabe mit <em>printf</em> und <em>cin/cout</em></h2>
<ul>
<li>
<p><code>printf(formatstring, ...)</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fluppie&#34;</span>;
</span></span><span style="display:flex;"><span>printf(<span style="color:#e6db74">&#34;hello world : %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, foo.c_str());</span></span></code></pre></div>
<ul>
<li>
<p>Einbinden über <code>#include &lt;cstdio&gt;</code></p>
</li>
<li>
<p>Format-String: Text und Formatierung der restlichen Parameter: <code>%[flags][width][.precision]conversion</code></p>
<ul>
<li>
<p><code>flags</code>: hängt von der konkreten Ausgabe ab</p>
</li>
<li>
<p><code>width</code>: Feldbreite</p>
</li>
<li>
<p><code>precision</code>: Anzahl der Dezimalstellen</p>
</li>
<li>
<p><code>conversion</code>: (Beispiele)</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">c</td>
          <td style="text-align: left">Zeichen (Char)</td>
      </tr>
      <tr>
          <td style="text-align: left">d</td>
          <td style="text-align: left">Integer (dezimal)</td>
      </tr>
      <tr>
          <td style="text-align: left">f</td>
          <td style="text-align: left">Gleitkommazahl</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Standardkanäle: <code>cin</code> (Standardeingabe), <code>cout</code> (Standardausgabe), <code>cerr</code> (Standardfehlerausgabe)</p>
<ul>
<li>Genauer: <code>cout</code> ist ein Ausgabestrom, auf dem der Operator <code>&lt;&lt;</code> schreibt</li>
<li>Einbinden über <code>#include &lt;iostream&gt;</code></li>
<li>Implementierung der Ein- und Ausgabeoperatoren (<code>&gt;&gt;</code>, <code>&lt;&lt;</code>) für Basistypen und Standardklassen vorhanden</li>
<li>Automatische Konvertierungen für Basistypen und Standardklassen</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Ausgabe, auch verkettet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>string foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fluppie&#34;</span>;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world : &#34;</span> <span style="color:#f92672">&lt;&lt;</span> foo <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// liest alle Ziffern bis zum ersten Nicht-Ziffernzeichen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (fuehrende Whitespaces werden ignoriert!)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> zahl; cin <span style="color:#f92672">&gt;&gt;</span> zahl;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Einzelne Zeichen (auch Whitespaces) lesen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> c; cin.get(c);</span></span></code></pre></div>
</li>
</ul>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/cin.cpp" target="_blank"><span class="title">Beispiel: cin.cpp</span></a></span></div>
<h2 id="sichtbarkeit-und-gültigkeit-und-namespaces">Sichtbarkeit und Gültigkeit und Namespaces</h2>
<p>Wie in Java:</p>
<ul>
<li>Namen sind nur nach Deklaration und innerhalb des Blockes, in dem sie deklariert wurden, gültig</li>
<li>Namen sind auch gültig für innerhalb des Blockes neu angelegte innere Blöcke</li>
<li>Namen in inneren Blöcken können Namen aus äußeren Scopes überdecken</li>
</ul>
<p>Zusätzlich gibt es noch benannte Scopes und einen Scope-Operator.</p>
<ul>
<li>
<p>C++ enthält den Scope-Operator <code>::</code> =&gt; Zugriff auf global sichtbare Variablen</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;lokal: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;global: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">::</span>a <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Alle Namen aus <code>XYZ</code> zugänglich machen: <code>using namespace XYZ;</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
</li>
<li>
<p>Alternativ gezielter Zugriff auf einzelne Namen: <code>XYZ::name</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;</span></span></code></pre></div>
</li>
</ul>
<!-- -->
<ul>
<li>
<p>Namensraum <code>XYZ</code> deklarieren</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> XYZ {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/cppScope.cpp" target="_blank"><span class="title">Beispiel: cppScope.cpp</span></a></span></div>
<h2 id="arrays-und-vektoren-in-c">Arrays und Vektoren in C++</h2>
<ul>
<li>
<p>Syntax: <code>Typ Name[AnzahlElemente];</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> myArray[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> myArray2[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>};</span></span></code></pre></div>
<ul>
<li>
<p><span class='alert'>Compiler</span> reserviert sofort Speicher auf dem <span class='alert'>Stack</span>
=&gt; <strong>statisch</strong>: im Programmlauf nicht änderbar</p>
</li>
<li>
<p>Zugriff über den Indexoperator []</p>
</li>
<li>
<p>Achtung: &quot;roher&quot; Speicher, d.h. <strong>keinerlei Methoden</strong></p>
</li>
<li>
<p>Größe nachträglich bestimmen mit <code>sizeof</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> myArray[<span style="color:#ae81ff">100</span>], i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(myArray)<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(myArryay[<span style="color:#ae81ff">0</span>]);</span></span></code></pre></div>
</li>
</ul>
<p><strong>Guter Stil</strong>: Anzahl der Elemente als Konstante deklarieren:
Statt <code>int myArray[100];</code> besser</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define LENGTH 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> myArray[LENGTH];</span></span></code></pre></div>
</li>
<li>
<p>Vordefinierter Vektor-Datentyp <code>vector</code></p>
<ul>
<li>Einbinden über <code>#include &lt;vector&gt;</code></li>
<li>Parametrisierter Datentyp (C++: Templates) - Nutzung analog wie in Java
(Erstellung von Templateklassen und -methoden aber deutlich anders!)</li>
<li>Anlegen eines neuen Arrays mit 10 Elementen für Integer:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> meinVektor <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">2.2</span>, <span style="color:#ae81ff">3.3</span>, <span style="color:#ae81ff">4.4</span>};
</span></span><span style="display:flex;"><span>meinVektor.push_back(<span style="color:#ae81ff">5.5</span>);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> meinVektor.size() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<ul>
<li>Zugriff auf Elemente:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> v[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> endl;        <span style="color:#75715e">// ohne Bereichspruefung!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>cout <span style="color:#f92672">&lt;&lt;</span> v.at(<span style="color:#ae81ff">1000</span>) <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">// mit interner Bereichspruefung
</span></span></span></code></pre></div>
<ul>
<li>Zuweisung (mit Kopieren):</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> andererVektor;
</span></span><span style="display:flex;"><span>andererVektor <span style="color:#f92672">=</span> meinVektor;</span></span></code></pre></div>
<ul>
<li>Dynamische Datenstruktur:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> meineDaten;      <span style="color:#75715e">// initiale Groesse: 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>meineDaten.push_back(<span style="color:#ae81ff">123</span>);   <span style="color:#75715e">// Wert anhaengen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>meineDaten.pop_back();  <span style="color:#75715e">// Wert loeschen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>meineDaten.empty();     <span style="color:#75715e">// leer?
</span></span></span></code></pre></div>
</li>
</ul>
<p><span class='alert'><strong>Vorsicht!</strong></span> <code>vector&lt;int&gt; arr();</code> ist <strong>kein</strong> Vektor der Länge 0,
sondern deklariert eine <strong>neue Funktion</strong>!</p>
<h2 id="alias-namen-für-typen-mit-typedef-und-using">Alias-Namen für Typen mit <em>typedef</em> und <em>using</em></h2>
<ul>
<li>
<p>Syntax: <code>typedef existTyp neuerName;</code> (C, C++)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> uint32;
</span></span><span style="display:flex;"><span>uint32 x, y, z;</span></span></code></pre></div>
<p>Im Beispiel ist <code>uint32</code> ein neuer Name für den existierenden Typ <code>unsigned long</code>, d.h.
die Variablen <code>x</code>, <code>y</code> und <code>z</code> sind <code>unsigned long</code>.</p>
</li>
<li>
<p>Syntax: <code>using neuerName = existTyp;</code> (C++)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> uint32;       <span style="color:#75715e">// C, C++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> uint32 <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>;       <span style="color:#75715e">// C++11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> foo;       <span style="color:#75715e">// C, C++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> foo <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>;       <span style="color:#75715e">// C++11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>fp)(<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">double</span>);     <span style="color:#75715e">// C, C++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> fp <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">double</span>);    <span style="color:#75715e">// C++11
</span></span></span></code></pre></div>
<p>Seit C++11 gibt es das Schlüsselwort <code>using</code> für Alias-Deklarationen (analog zu <code>typedef</code>).
Dieses funktioniert im Gegensatz zu <code>typedef</code> auch für Templates mit (teilweise) gebundenen
Template-Parametern.</p>
</li>
</ul>
<h2 id="erinnerungen-an-c---vergleich-mit-c">Erinnerungen an C - Vergleich mit C++</h2>
<div class="box notices cstyle important">
  <div class="box-label">
    <i class="fa-fw fas fa-bolt"></i> Erinnerungen an C - Vergleich mit C++
  </div>
  <div class="box-content">
<div class="expand">
  <input type="checkbox" id="R-expand-25609e0ca1b74013361c0e30feb0a660" aria-controls="R-expandcontent-25609e0ca1b74013361c0e30feb0a660">
  <label class="expand-label" for="R-expand-25609e0ca1b74013361c0e30feb0a660">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Expand me&hellip;
  </label>
  <div id="R-expandcontent-25609e0ca1b74013361c0e30feb0a660" class="expand-content">
<h3 id="basisdatentypen">Basisdatentypen</h3>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>char</code></td>
          <td style="text-align: left">Zeichen (ASCII, 8 Bit bzw. 1 Byte)</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>int</code></td>
          <td style="text-align: left">Ganze Zahl (16, 32 oder 64 Bit)</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>float</code></td>
          <td style="text-align: left">Gleitkommazahl (typ. 32 Bit)</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>double</code></td>
          <td style="text-align: left">Doppelt genaue Gleitkommazahl (typ. 64 Bit)</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>void</code></td>
          <td style="text-align: left">Ohne/kein Wert</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>bool</code></td>
          <td style="text-align: left"><code>true</code>, <code>false</code></td>
      </tr>
  </tbody>
</table>
<p>Außerdem sind Arrays und Pointer mit diesen Typen möglich.</p>
<h3 id="typmodifikatoren-ändern-bedeutung">Typmodifikatoren ändern Bedeutung</h3>
<p>Vorangestellte Modifikatoren ändern Bedeutung:</p>
<ol>
<li>
<p>Länge im Speicher</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>short</code></td>
          <td style="text-align: left">Speicher: halbe Wortlänge</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>long</code></td>
          <td style="text-align: left">Speicher: doppelte/dreifache Wortlänge</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>Vorzeichen</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>signed</code></td>
          <td style="text-align: left">mit Vorzeichen (Default bei Zahlen)</td>
      </tr>
      <tr>
          <td style="text-align: left"><code>unsigned</code></td>
          <td style="text-align: left">ohne Vorzeichen</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<p>Anwendung auf ganze Zahlen:</p>
<ul>
<li><code>short</code> und <code>long</code> sind Synonyme für <code>short int</code> und <code>long int</code></li>
<li><code>long long</code> ist typischerweise eine ganze Zahl mit 8 Byte</li>
<li><code>unsigned char</code> sind Zahlen von 0, ..., 255 (1 Byte)</li>
<li>zusätzlich: <code>long double</code> (nur diese Form)</li>
</ul>
<p>Sie können <code>short</code>, <code>long</code> und <code>long long</code> nur für ganze Zahlen (<code>int</code>) nutzen, mit der Ausnahme <code>long double</code>.
Dagegen können <code>signed</code> und <code>unsigned</code> sowohl für <code>char</code> als auch für <code>int</code> benutzt werden.</p>
<p>vgl. <a href="https://en.wikipedia.org/wiki/C_data_types" rel="external" target="_blank">en.wikipedia.org/wiki/C_data_types</a></p>
<h3 id="größe-eines-datentyps-ist-maschinenabhängig">Größe eines Datentyps ist maschinenabhängig</h3>
<div class='center'>
<p><span class='alert'><strong>Der reservierte Speicherbereich und damit auch der Zahlenbereich für einen einfachen Typ in C/C++ ist maschinenabhängig!</strong></span></p>
</div>
<ul>
<li>
<p>Zahlenbereiche für konkrete Implementierung in Header-Files definiert</p>
<p><code>limits.h</code> und <code>float.h</code>: Konstanten <code>INT_MAX</code>, <code>INT_MIN</code>, ...</p>
</li>
<li>
<p>Alternativ Herausfinden der Größe in Bytes: Operator <code>sizeof</code></p>
<p>Syntax: <code>sizeof(Typ)</code></p>
</li>
</ul>
<p>Es gilt in C/C++:</p>
<ul>
<li><code>sizeof(unsigned char)</code> <span class="math align-center">$=$</span> 1</li>
<li><code>sizeof(short int)</code> <span class="math align-center">$=$</span> 2</li>
<li><code>sizeof(short int)</code> <span class="math align-center">$\le$</span> <code>sizeof(int)</code> <span class="math align-center">$\le$</span> <code>sizeof(long int)</code></li>
<li><code>sizeof(float)</code> <span class="math align-center">$\le$</span> <code>sizeof(double)</code> <span class="math align-center">$\le$</span> <code>sizeof(long double)</code></li>
</ul>
<p><strong>Hinweis Arrays</strong>: <code>sizeof</code> gibt immer die Anzahl der Bytes für einen Typ oder eine
Variable zurück. Bei Array ist das nicht unbedingt die Anzahl der Elemente im Array!</p>
<p>Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> b[<span style="color:#ae81ff">10</span>];</span></span></code></pre></div>
<p><code>sizeof(a)</code> würde den Wert 10 als Ergebnis liefern, da ein <code>char</code> in C/C++ immer exakt ein
Byte benötigt und entsprechend 10 <code>char</code> 10 Byte. <code>sizeof(b)</code> ist maschinenabhängig und
liefert die Anzahl der Bytes, die man für die Darstellung von 10 Double-Werten benötigt.</p>
<p>Wenn man die Anzahl der Elemente im Array mit <code>sizeof</code> herausfinden will, muss man den
Gesamtwert für das Array noch durch den Speicherbedarf eines Elements teilen, also
beispielsweise <code>sizeof(b)/sizeof(b[0])</code>.</p>
<h3 id="beispiele-für-schleifen-und-kontrollstrukturen-in-cc">(Beispiele für) Schleifen und Kontrollstrukturen in C/C++</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (x<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(y<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> y<span style="color:#f92672">-</span>x;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (y<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    y<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; x<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> y<span style="color:#f92672">*</span>y;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="funktionen-in-c-und-c">Funktionen in C und C++</h3>
<ul>
<li>
<p>Funktionen sind mit Methoden in Java vergleichbar</p>
<p>=&gt; sind aber <span class='alert'>unabhängig</span> von Klassen bzw. Objekten</p>
</li>
<li>
<p>Syntax:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Rueckgabetyp <span style="color:#a6e22e">Funktionsname</span>(Parameterliste) {
</span></span><span style="display:flex;"><span>    Anweisungen (Implementierung)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Aufruf: Nennung des Namens (mit Argumenten) im Programmcode</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> foo(<span style="color:#ae81ff">42</span>);</span></span></code></pre></div>
</li>
</ul>
<p>Anmerkung: Unterschied &quot;Parameter&quot; und &quot;Argument&quot;:</p>
<ul>
<li>Funktion hat &quot;Parameter&quot; in ihrer Parameterliste, auch &quot;formale Parameter&quot; genannt</li>
<li>Beim Aufruf werden &quot;Argumente&quot; übergeben, auch &quot;aktuelle Parameter&quot; genannt</li>
</ul>
<p>In der Praxis verwendet man beide Begriffe i.d.R. synonym.</p>
<h4 id="funktionen-deklaration-vs-definition">Funktionen: Deklaration vs. Definition</h4>
<ul>
<li>
<p><strong>Deklaration</strong>: <span class='alert'>(Funktions-) Prototyp</span>: Festlegen von
<span class='alert'>Signatur</span> (d.h. Funktionsname und Anzahl, Typ, Reihenfolge der Parameter) u. Rückgabetyp</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">machWas</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);</span></span></code></pre></div>
</li>
<li>
<p><strong>Definition</strong>: <span class='alert'>Implementierung</span> der Funktion</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">machWas</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, b: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Compiler &quot;liest&quot; Quellcode von oben nach unten</p>
</li>
<li>
<p>Funktionen müssen (wie alle anderen Symbole auch) <span class='alert'>vor</span> ihrer Verwendung zumindest
<span class='alert'>deklariert</span> sein, d.h. es muss zumindest ihre Signatur bekannt sein (siehe nächste Folie)</p>
</li>
<li>
<p>Deklaration: Variablennamen können weggelassen werden</p>
</li>
</ul>
<div class="box notices cstyle info">
  <div class="box-label">
    <i class="fa-fw fas fa-info-circle"></i> Deklaration vs. Definition
  </div>
  <div class="box-content">
<ul>
<li><strong>Deklaration</strong>: Macht einen Namen bekannt und legt den Typ der Variablen bzw.
die Schnittstelle der Funktionen fest.</li>
<li><strong>Definition</strong>: Deklaration plus Reservierung von Speicherplatz für die
Variable oder Implementierung einer Funktion/Struktur/...</li>
</ul>
  </div>
</div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/simplefunction.cpp" target="_blank"><span class="title">Konsole: simplefunction.cpp</span></a></span></div>
<h4 id="one-definition-rule-für-funktionen">One Definition Rule (für Funktionen)</h4>
<div class='center'>
<p>Jede Funktion darf im <strong>gesamten</strong> Programm nur <span class='alert'><strong>einmal definiert</strong></span> sein!</p>
</div>
<h4 id="funktionen-und-parameter">Funktionen und Parameter</h4>
<ul>
<li>
<p>Funktionen &quot;ohne&quot; Parameter:</p>
<p>Leere Parameter-Liste[^1] oder Schlüsselwort <code>void</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">void</span>);</span></span></code></pre></div>
</li>
<li>
<p>Funktionen <strong>mit</strong> Parameter:</p>
<ul>
<li>Deklaration: Variablennamen können weggelassen werden</li>
<li>Definition: Variablennamen müssen angegeben werden</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">char</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">char</span> b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">char</span> b) { ... }</span></span></code></pre></div>
</li>
</ul>
<h5 id="leere-parameterliste-in-c">Leere Parameterliste in C</h5>
<p>Wenn eine Funktion keine Parameter hat, können Sie wie in C die Parameterliste
entweder einfach leer lassen (<code>int fkt();</code>) oder das Schlüsselwort <code>void</code>
nutzen (<code>int fkt(void);</code>).</p>
<p>Betrachten Sie folgendes Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Legal in C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">wuppie</span>();                   <span style="color:#75715e">// Deklaration: &#34;Ich verrate Dir nicht, wieviele Parameter wuppie() hat.&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">wuppie</span>(<span style="color:#66d9ef">int</span> x) { <span style="color:#66d9ef">return</span> x; } <span style="color:#75715e">// Aufruf mit Argumenten =&gt; ist okay
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Fehler in C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fluppie</span>(<span style="color:#66d9ef">void</span>);               <span style="color:#75715e">// Deklaration: fluppie() hat KEINE Parameter!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fluppie</span>(<span style="color:#66d9ef">int</span> x) { <span style="color:#66d9ef">return</span> x; } <span style="color:#75715e">// Aufruf mit Argumenten =&gt; Compiler-Fehler
</span></span></span></code></pre></div>
<p>Wenn Sie eine mit leerer Parameterliste deklarierte Funktion definieren bzw.
aufrufen, akzeptiert der C-Compiler dennoch <strong>alle</strong> übergebenen Parameter. Dies
kann zu schwer verständlichen Fehlern führen! Sobald eine Funktion explizit
mit dem Schlüsselwort <code>void</code> in der Parameterliste deklariert wird, <strong>muss</strong>
diese dann auch ohne Parameter aufgerufen werden.</p>
<p><span class='alert'>=&gt; <strong>Bevorzugen Sie in C die Variante mit dem Schlüsselwort <code>void</code>!</strong></span></p>
<h5 id="leere-parameterliste-in-c-1">Leere Parameterliste in C++</h5>
<p>Keine Parameter: Leere Liste und Schlüsselwort <code>void</code> <strong>gleichwertig</strong></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">void</span>);</span></span></code></pre></div>
<h4 id="defaultparameter-in-c">Defaultparameter in C++</h4>
<ul>
<li>Parameter mit Defaultwerten am <span class='alert'><strong>Ende</strong></span> der Parameterliste</li>
<li>Bei Trennung von Deklaration und Definition: Defaultparameter
<span class='alert'><strong>nur</strong></span> in Deklaration</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Deklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Definition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j, <span style="color:#66d9ef">int</span> k) { ... }</span></span></code></pre></div>
<h4 id="überladen-von-funktionen">Überladen von Funktionen</h4>
<ul>
<li>Funktionen im <strong>gleichen Gültigkeitsbereich</strong> können überladen werden</li>
<li>Zu beachten:
<ol>
<li>Funktionsname identisch</li>
<li>Signatur (Anzahl, Typen der Parameter) muss <span class='alert'>unterschiedlich</span> sein</li>
<li>Rückgabewert darf variieren</li>
</ol>
</li>
</ul>
<p>=&gt; <span class='alert'>Warnung</span>: Überladene Funktionen sollten gleichartige
Operationen für unterschiedliche Datentypen bereitstellen!</p>
<h4 id="probleme-beim-überladen-von-funktionen">Probleme beim Überladen von Funktionen</h4>
<ol>
<li>
<p>Defaultparameter</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>);</span></span></code></pre></div>
</li>
<li>
<p>Identische Signatur, Unterschied nur im Rückgabewert</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);</span></span></code></pre></div>
</li>
<li>
<p>Überladen nur für Funktionen des selben Gültigkeitsbereichs!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">char</span> c) {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f(char): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f(int): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> f(<span style="color:#66d9ef">int</span> i);  <span style="color:#75715e">// f(char) nicht mehr sichtbar!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f(<span style="color:#e6db74">&#39;a&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ol>
<h4 id="parameterübergabe-in-cc-call-by-value">Parameterübergabe in C/C++: Call-by-Value</h4>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add_5</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> erg, i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    erg <span style="color:#f92672">=</span> add_5(i);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<div class='column'>
<pre><code> Aufrufer-Sicht
              i                      erg
           +-----+                 +-----+
           |     |                 |     |
           +--+--+                 +--^--+
              |                       |
              |                       |
--------------+-----------------------+-----
  Kopie bei   |                Kopie  |
  Aufruf      |                bei    |
              |                return |
           +--v--+                    |
           |     +--------------------+
           +-----+
              x
 Funktionssicht
</code></pre>
</div>
</div>
<ul>
<li>Default in C/C++ ist die <span class='alert'>call-by-value</span> Semantik:
<ul>
<li>Argumente werden bei Übergabe <span class='alert'>kopiert</span></li>
<li>Ergebniswerte werden bei Rückgabe <span class='alert'>kopiert</span></li>
</ul>
</li>
<li>Folgen:
<ul>
<li>Keine Seiteneffekte durch Verändern von übergebenen Strukturen</li>
<li>Negative Auswirkungen auf Laufzeit bei großen Daten</li>
</ul>
</li>
</ul>
<p>Ausnahme: Übergabe von C++-Referenzen oder Pointern
(wobei Pointer streng genommen auch kopiert werden, also per call-by-value übergeben werden ...)</p>
<h3 id="unterschiedliche-variablenarten">Unterschiedliche Variablenarten</h3>
<h4 id="lokale-variablen-automatische-variablen">Lokale Variablen (&quot;automatische Variablen&quot;)</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>
<p>Innerhalb einer Funktion (oder Blockes) definierte Variablen</p>
</li>
<li>
<p>Gilt auch für Variablen aus Parameterliste</p>
</li>
<li>
<p>Überdecken <strong>globale Variablen</strong> gleichen Namens</p>
</li>
<li>
<p>Sichtbarkeit:</p>
<ul>
<li>Außerhalb der Funktion/Blockes nicht zugreifbar</li>
<li>Beim Betreten der Funktion Reservierung von Speicherplatz für lokale
Variablen</li>
<li>Dieser wird beim Verlassen des Blockes/Funktion automatisch wieder
freigegeben</li>
<li>Namen sind nur nach Deklaration und innerhalb des Blockes, in dem sie
deklariert wurden, gültig</li>
<li>Namen sind auch gültig für innerhalb des Blockes neu angelegte innere
Blöcke</li>
</ul>
<p>Software Engineering: Vermeiden Sie lokale Namen, die Namen aus einem
äußeren Scope überdecken!</p>
</li>
</ul>
<p>=&gt; Werden auch als <span class='alert'><strong>automatische Variablen</strong></span> bezeichnet</p>
<h4 id="globale-variablen-externe-variablen">Globale Variablen (&quot;externe Variablen&quot;)</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei main.cpp (einzeln kompilierbar) ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> global;  <span style="color:#75715e">// Deklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> global;             <span style="color:#75715e">// Definition
</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei foo.cpp (einzeln kompilierbar) ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> global;      <span style="color:#75715e">// Deklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>    global <span style="color:#f92672">=</span> <span style="color:#ae81ff">45</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Globale Variablen: Außerhalb <strong>jeder</strong> Funktion definierte Variablen</li>
<li>Globale Variablen gelten in <span class='alert'>allen</span> Teilen des Programms</li>
<li>Auch in anderen Dateien! =&gt; müssen bei <em>Nutzung</em> in Funktionen als <code>extern</code> deklariert werden</li>
<li>Existieren die <strong>gesamte</strong> Programmlebensdauer über</li>
</ul>
<p>=&gt; Werden auch als <span class='alert'><strong>externe Variablen</strong></span> bezeichnet</p>
<p>Die Dateien sind einzeln kompilierbar (<code>extern</code> sagt dem Compiler, dass
die Variable woanders definiert ist) =&gt; erst der Linker löst das auf.</p>
<p><em>Hinweis</em>: Bei globalen Konstanten in C++ brauchen Sie zusätzlich auch bei der Definition ein &quot;<code>extern</code>&quot;,
da die Konstante sonst nur in ihrer Datei sichtbar ist.</p>
<h4 id="statische-lokale-variablen">Statische lokale Variablen</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    foo();  foo();  foo();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>
<p>Lokale Variablen mit &quot;Gedächtnis&quot;: Definition mit dem vorangestellten Schlüsselwort &quot;static&quot;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> callCount;</span></span></code></pre></div>
</li>
<li>
<p>Eigenschaften:</p>
<ul>
<li>Wert bleibt für die folgenden Funktionsaufrufe erhalten</li>
<li>Wert kann in der Funktion verändert werden</li>
<li>Dennoch: lokale Variable, d.h. von außen nicht sichtbar/gültig</li>
</ul>
</li>
</ul>
<p><em>Hinweis</em>: <code>static</code> für globale Variablen bedeutet etwas anderes! (s.u. &quot;Sichtbarkeit&quot;)</p>
<h4 id="initialisierung-von-variablen">Initialisierung von Variablen</h4>
<p>(Automatische) Initialisierung von Variablen hängt von ihrer Speicherklasse ab!</p>
<ul>
<li><strong>Automatisch</strong>
<ul>
<li>Werden <span class='alert'>nicht</span> automatisch initialisiert (!)</li>
<li>Bei vorgegebenem Wert ab Aufruf der Funktion</li>
</ul>
</li>
<li><strong>Extern</strong>
<ul>
<li>Mit dem Wert 0 oder vorgegebenem Wert</li>
<li>Bereits vor Programmstart (im Code enthalten)</li>
</ul>
</li>
<li><strong>Statisch</strong>
<ul>
<li>Mit dem Wert 0 oder vorgegebenem Wert</li>
<li>Ab erstem Aufruf der Funktion</li>
</ul>
</li>
</ul>
<h4 id="sichtbarkeit-globaler-variablen-und-funktionen-beschränken">Sichtbarkeit globaler Variablen (und Funktionen) beschränken</h4>
<ul>
<li>Beschränkung der Gültigkeit von <strong>globalen Variablen</strong> auf die Datei, wo
sie definiert sind: <strong>Schlüsselwort <code>static</code></strong>
<ul>
<li>werden (weiterhin) automatisch mit 0 initialisiert</li>
<li>sind nun nur in der Datei sichtbar/gültig, wo sie definiert sind</li>
<li>dient zur Vermeidung von Namenskonflikten bei globalen Variablen</li>
</ul>
</li>
<li>Sichtbarkeitsbeschränkung gilt auch für <strong>Funktionen</strong></li>
</ul>
<p><code>static</code> für globale Variablen beschränkt deren Sichtbarkeit auf die Datei,
wo sie definiert sind. D.h. man kann diese dann nicht in einer anderen Datei
nutzen, nicht mal mit <code>extern</code> ...</p>
<p><code>static</code> für Funktionen beschränkt deren Sichtbarkeit ebenfalls auf die Datei,
wo sie definiert sind. Man kann sie dann nur in anderen Funktionen, die
ebenfalls in der selben Datei definiert werden, nutzen. In anderen Dateien sind
die <code>static</code> Funktionen <em>nicht</em> sichtbar. D.h. es macht auch keinen Sinn, sie
in einer Header-Datei zu deklarieren! (In der Praxis liefert der gcc dann sogar
einen Fehler!). Das ist mit <code>private</code> Methoden vergleichbar.</p>
<h3 id="globale-konstanten">Globale Konstanten</h3>
<h4 id="in-c-funktionieren-globale-konstanten-wie-globale-variablen">In C funktionieren globale Konstanten wie globale Variablen</h4>
<ul>
<li>
<p><strong>Definition</strong> in einer Übersetzungseinheit ohne &quot;<code>extern</code>&quot;</p>
<p>=&gt; Definition als &quot;<code>extern</code>&quot; wird in C mit einer Warnung quittiert!</p>
</li>
<li>
<p>Nutzung in anderen Übersetzungseinheiten durch (erneute)
<strong>Deklaration</strong> als &quot;<code>extern</code>&quot;</p>
</li>
<li>
<p>Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei main.c ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI<span style="color:#f92672">=</span><span style="color:#ae81ff">123</span>;       <span style="color:#75715e">// Definition OHNE &#34;extern&#34; (C)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fkt_a1</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei a.c ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI;    <span style="color:#75715e">// (erneute) Deklaration mit &#34;extern&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt_a1</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<h4 id="in-c-sind-globale-konstanten-per-default-nur-in-ihrer-definitionsdatei-sichtbar">In C++ sind globale Konstanten per Default nur in ihrer Definitionsdatei sichtbar!</h4>
<ul>
<li>
<p>Abhilfe: Definieren <em>und</em> Deklarieren mit <code>extern</code></p>
</li>
<li>
<p>Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei main.cpp ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI<span style="color:#f92672">=</span><span style="color:#ae81ff">123</span>;    <span style="color:#75715e">// Definition MIT &#34;extern&#34; (C++)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    fkt_a1();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei a.cpp ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI;        <span style="color:#75715e">// (erneute) Deklaration mit &#34;extern&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt_a1</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<h4 id="alternativ-in-beiden-sprachen-konstanten-vorwärts-deklarieren">Alternativ: In beiden Sprachen Konstanten vorwärts deklarieren</h4>
<p>Folgende Definition und (Vorwärts-) Deklaration der Konstanten <code>PI</code>
funktioniert sowohl in C als auch in C++:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei main.c ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI;    <span style="color:#75715e">// (Vorwärts-) Deklaration mit &#34;extern&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI<span style="color:#f92672">=</span><span style="color:#ae81ff">123</span>;       <span style="color:#75715e">// Definition OHNE &#34;extern&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fkt_a1</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ======== Datei a.c ======== */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI;    <span style="color:#75715e">// (erneute) Deklaration mit &#34;extern&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt_a1</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> PI;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="automatisieren-der-buildvorgänge-gnu-make">Automatisieren der Buildvorgänge: GNU Make</h3>
<h4 id="makefile-textdatei-mit-regeln-für-das-programm-make">Makefile: Textdatei mit Regeln für das Programm <code>make</code></h4>
<ul>
<li>Abläufe automatisieren: Kompilieren, testen, Pakete bauen, aufräumen, ...</li>
<li>Java: <code>ant</code>, C/C++: <code>make</code></li>
<li>Achtung: Verschiedene Make-Dialekte! Wir nutzen <em>GNU Make</em>!</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span> <span style="color:#75715e"># Kommentar</span>
</span></span><span style="display:flex;"><span> Ziel1: AbhaengigkeitenListe1
</span></span><span style="display:flex;"><span>     Aktionen1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Ziel2: AbhaengigkeitenListe2
</span></span><span style="display:flex;"><span>     Aktionen2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># ... und so weiter :-)</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># ACHTUNG:</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Vor den Aktionen &lt;TAB&gt; benutzen, keine Leerzeichen!!!</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Vorsicht mit Editor-Einstellungen!</span>
</span></span></code></pre></div>
<p>Bedeutung: Um das Ziel <code>Ziel1</code> zu erzeugen, müssen alle Abhängigkeiten der Liste
<code>AbhaengigkeitenListe1</code> erfüllt sein. Dann werden die Aktionen in <code>Aktionen1</code> durchgeführt,
um <code>Ziel1</code> zu erzeugen. Aber nur, falls das Ziel <code>Ziel1</code> nicht existiert oder veraltet ist!</p>
<p>Falls die Abhängigkeiten nicht erfüllt sind, wird nach Regeln gesucht, um diese zu erzeugen.
Das bedeutet, dass u.U. zunächst weitere Targets &quot;gebaut&quot; werden, bevor die Aktionenliste
ausgeführt wird.</p>
<p>Die Ziele und Abhängigkeiten sind i.d.R. Dateien (müssen es aber nicht sein).</p>
<h4 id="makefiles-fiktives-beispiel">Makefiles: Fiktives Beispiel</h4>
<ul>
<li>
<p>Annahme: Projekt besteht aus der Datei <code>main.cpp</code>, daraus soll das Programm
&quot;tollesProgramm&quot; erzeugt werden</p>
</li>
<li>
<p>Passendes Makefile:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>CXXFLAGS <span style="color:#f92672">=</span> -Wall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> all
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all</span><span style="color:#f92672">:</span> tollesProgramm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tollesProgramm</span><span style="color:#f92672">:</span> main.o
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">$(</span>CXX<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>LDFLAGS<span style="color:#66d9ef">)</span> $&lt; <span style="color:#66d9ef">$(</span>LDLIBS<span style="color:#66d9ef">)</span> -o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">%.o</span><span style="color:#f92672">:</span> %.cpp
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">$(</span>CXX<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>CXXFLAGS<span style="color:#66d9ef">)</span> -c $&lt; -o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> clean
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    rm -rf tollesProgramm *.o *.~
</span></span></code></pre></div>
</li>
</ul>
<p>Bedeutung: Um das Ziel <code>all</code> zu erzeugen, muss die Abhängigkeit <code>tollesProgramm</code> erfüllt sein.
Beachten Sie, dass im Beispiel <code>all</code> kein Dateiname ist, <code>tollesProgramm</code> dagegen schon.</p>
<p>Um <code>tollesProgramm</code> zu erzeugen, muss die Datei <code>main.o</code> vorhanden sein. Falls sie es nicht
ist, wird sie mit Hilfe des dritten Targets erzeugt. Das <code>%</code> ist dabei ein Patternmatcher,
d.h. wenn nach einem <code>main.o</code> gesucht ist, matcht <code>%.o</code> (das <code>%</code> bindet sich dabei an &quot;main&quot;)
und auf der rechten Seite des Targets steht als Abhängigkeit <code>main.cpp</code>.</p>
<p>Die Variablen <code>CXX</code>, <code>CXXFLAGS</code>, <code>LDFLAGS</code> und <code>LDLIBS</code> sind vordefinierte Variablen:</p>
<ul>
<li><code>CXX</code>: C++-Compiler, Default: <code>g++</code></li>
<li><code>CXXFLAGS</code> Extra Flags für den C++-Compiler (nur für Kompilieren)</li>
<li><code>LDFLAGS</code>: Extra Flags, die für das Linken genutzt werden (Beispiel: <code>-L.</code>; <strong>nicht</strong> <code>-lm</code>)</li>
<li><code>LDLIBS</code>: Bibliotheken, die für das Linken genutzt werden (Beispiel: <code>-lm -lfoo</code>; <strong>nicht</strong> <code>-L.</code>)</li>
</ul>
<p>Die Variablen <code>$&lt;</code>, <code>$^</code> und <code>$@</code> lösen auf das Ziel bzw. die Abhängigkeiten eines Targets auf:</p>
<ul>
<li><code>$&lt;</code> =&gt; gibt die erste Abhängigkeit an</li>
<li><code>$^</code> =&gt; gibt alle Abhängigkeiten an</li>
<li><code>$@</code> =&gt; gibt das Ziel an</li>
</ul>
<p>Falls die Datei <code>tollesProgramm</code> nicht existiert oder aber älter ist als <code>main.o</code>, wird die
Regel des Targets <code>tollesProgramm</code> ausgeführt, um die Datei <code>tollesProgramm</code> zu erzeugen:
<code>g++ main.o -o tollesProgramm</code>.</p>
<p><strong>Hinweis</strong>: Das Beispiel entspricht den minimalen Kenntnissen, die Sie über Make haben müssen.</p>
<h4 id="makefiles-typische-aufrufe">Makefiles: Typische Aufrufe</h4>
<ul>
<li>
<p><code>make</code>
Sucht nach Datei mit dem Namen &quot;GNUmakefile&quot;, &quot;makefile&quot; oder &quot;Makefile&quot; und erzeugt das
erste Ziel in der Datei</p>
<p>Konvention: Das erste Ziel hat den Namen <code>all</code></p>
</li>
<li>
<p><code>make -f &lt;datei&gt;</code>
Sucht die Datei mit dem angegebenen Namen, erzeugt das erste Ziel in der Datei</p>
</li>
<li>
<p><code>make -f &lt;datei&gt; &lt;ziel&gt;</code>
Sucht die Datei mit dem angegebenen Namen, erzeugt das Ziel <code>&lt;ziel&gt;</code></p>
</li>
<li>
<p><code>make &lt;ziel&gt;</code>
Sucht nach Datei mit dem Namen &quot;GNUmakefile&quot;, &quot;makefile&quot; oder &quot;Makefile&quot; und erzeugt das
Ziel <code>&lt;ziel&gt;</code></p>
</li>
</ul>
  </div>
</div>
  </div>
</div>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>C/C++ sind enge Verwandte: kompilierte Sprachen, C++ fügt OO hinzu</p>
</li>
<li>
<p>Funktionsweise einfachster Make-Files</p>
</li>
<li>
<p>Wichtigste Unterschiede zu Java</p>
<ul>
<li>Kontrollfluss wie in Java</li>
<li>Basisdatentypen vorhanden</li>
<li>Typ-Modifikatoren zur Steuerung des Speicherbedarfs/Wertebereich</li>
<li>Integer können im booleschen Kontext ausgewertet werden</li>
<li>Operator <code>sizeof</code> zur Bestimmung des Speicherbedarfs</li>
<li>Alias-Namen für existierende Typen mit <code>typedef</code> definierbar</li>
<li>Funktionen mit Default-Parametern und Überladung</li>
</ul>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<ul>
<li>
<p>Wie groß ist der Bereich der Basisdatentypen (Speicherbedarf, Zahlenbereich)?
Wie können Sie das feststellen?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> x[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> y[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> z[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3</span>};</span></span></code></pre></div>
</li>
<li>
<p>Erklären Sie den Unterschied <code>sizeof(x)</code> vs. <code>sizeof(x)/sizeof(x[0])</code>!</p>
</li>
<li>
<p>Warum ist der folgende Code-Schnipsel gefährlich?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Vorsicht&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Vorsicht (auch hier)&#34;)</span>;</span></span></code></pre></div>
</li>
<li>
<p>Limits kennen: Datentypen, Wertebereiche</p>
<p>Schreiben Sie ein C-Programm, welches die größtmögliche <code>unsigned int</code> Zahl
auf Ihrem System berechnet.</p>
<p>Verwenden Sie hierzu <strong>nicht</strong> die Kenntnis der systemintern verwendeten Bytes
(<code>sizeof</code>, ...). Nutzen Sie auch nicht die Konstanten/Makros/Funktionen aus
<code>limits.h</code> oder <code>float.h</code> oder anderen Headerdateien!</p>
</li>
<li>
<p>Erklären Sie die Probleme bei folgendem Code-Schnipsel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>);</span></span></code></pre></div>
</li>
<li>
<p>Erklären Sie die Probleme bei folgendem Code-Schnipsel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">maximum</span>(<span style="color:#66d9ef">double</span>, <span style="color:#66d9ef">double</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> maximum(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2.2</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Erklären Sie den Unterschied zwischen</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>und</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Pointer und Referenzen</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Es gibt viele Arten Speicher, die sich vor allem in der Größe und Geschwindigkeit unterscheiden
(Cache, RAM, SSD, Festplatte, ...). Der Kernel stellt jedem Prozess einen linearen Adressraum
bereit und abstrahiert dabei von den darunter liegenden physikalischen Speichermedien (es gibt
eine Abbildung auf die jeweiligen Speichermedien durch die MMU, dies ist aber nicht Bestandteil
dieses Kurses).</p>
<p>Den virtuellen Speicher kann man grob in drei Segmente aufteilen: Text (hier befindet sich der
Programmcode des Prozesses), Stack (automatische Verwaltung, für Funktionsaufrufe und lokale
Variablen) und Heap (Verwaltung durch den Programmierer, dynamische Bereitstellung von Speicher
während der Laufzeit des Programms).</p>
<p>Pointer sind Variablen, deren <strong>Wert als Adresse</strong> (im virtuellen Speicher) interpretiert wird.
Pointer können auf andere Objekte bzw. Variablen zeigen: Der Adressoperator &quot;<code>&amp;</code>&quot; liefert die
Adresse eines Objekts im virtuellen Speicher, diese kann einem Pointer zugewiesen werden (der
Wert des Pointers ist dann die zugewiesene Adresse). Pointer können mit &quot;<code>*</code>&quot; dereferenziert
werden, d.h. es wird an der Speicherstelle im virtuellen Speicher nachgeschaut, deren Adresse
im Pointer gespeichert ist. Dadurch erfolgt der Zugriff auf das verwiesene Objekt. (Dies hat
noch nichts mit <em>dynamischer Speicherverwaltung</em> zu tun!) Die Deklaration eines Pointers erfolgt
mit einem <code>*</code> zwischen Typ und Pointername: <code>int *p;</code>. Da Pointer normale Variablen sind, unterliegen
Pointer-Variablen den üblichen Gültigkeitsbedingungen (Scopes).</p>
<p>In C++ gibt es zusätzlich <strong>Referenzen</strong>. Diese stellen Alias-Namen für ein Objekt (oder eine Variable)
dar, d.h. ein Zugriff auf eine Referenz bewirkt den direkten Zugriff auf das verbundene Objekt.
Referenzen müssen bei der Deklaration initialisiert werden (<code>Typ &amp;ref = obj;</code>) und sind dann
fest mit diesem Objekt verbunden.</p>
<p>In C und C++ werden Funktionsparameter immer per Call-by-Value übergeben: Der Wert des Arguments wird
in die lokale Variable des Funktionsparameters kopiert. Wenn ein Pointer übergeben wird, wird entsprechend
der Wert des Pointers kopiert, also die gespeicherte Adresse. Mit der Adresse eines Objekts kann man
aber auch in der Funktion direkt auf dieses Objekt zugreifen und dieses auslesen und verändern, d.h.
durch die Übergabe eines Pointers hat man zwar immer noch Call-by-Value (die Adresse wird kopiert), die
Wirkung ist aber wie bei Call-by-Reference (also als ob eine Referenz auf das Objekt übergeben wurde).
Bei der Verwendung von C++-Referenzen hat man dagegen echtes Call-by-Reference.</p>
<p>Zur Laufzeit kann man Speicher auf dem Heap reservieren (<em>allozieren</em>). Im Gegensatz zu Speicher auf dem
Stack ist man selbst auch für die Freigabe des reservierten Speichers zuständig - wenn man dies nicht beachtet,
läuft irgendwann der Heap voll. Allokation und Freigabe kann entweder mit den C-Funktionen <code>malloc</code> und <code>free</code>
erfolgen oder mit den C++-Operatoren <code>new</code> und <code>delete</code>. Mischen Sie niemals nie <code>malloc()</code>/<code>free()</code> mit
<code>new</code>/<code>delete</code>!</p>
<p>Zwischen Pointern und Arrays gibt es eine enge Verwandschaft. Die einzelnen Elemente eines Arrays
werden vom Compiler direkt aufeinanderfolgend im Speicher angeordnet, der Array-Name ist wie
ein (konstanter) Pointer auf das erste Element. Tatsächlich übersetzt der Compiler Indexzugriffe
für ein Array in die passende Pointerdereferenzierung: <code>a[i]</code> wird zu <code>*(a+i)</code>. Ein Pointer kann
wiederum auch auf das erste Element eines zusammenhängenden Speicherbereichs zeigen, etwa wenn man
über <code>malloc</code> Speicherplatz für mehrere Elemente anfordert. Da der Compiler aus einem Indexzugriff
ohnehin die Pointerdereferenzierung macht, könnte man so einen Pointer auch per Indexzugriff
abfragen. Dies ist aber gefährlich: Es funktioniert auch, wenn der Pointer nur auf <em>ein</em> anderes
Objekt zeigt und nicht auf einen Speicherbereich ... Ein Arrayname wird vom Compiler fest der
ersten Speicheradresse des Arrays zugeordnet und kann nicht verändert werden, der Inhalt eines
(nicht-konstanten) Pointer dagegen schon (der Pointer selbst wird auch fest im Speicher angelegt).</p>
<p>Pointer haben einen Typ: Die Pointerarithmetik berücksichtigt die Speicherbreite des Typs! Damit
springt man mit <code>ptr+1</code> automatisch zum nächsten Objekt und nicht notwendigerweise zum nächsten
Byte.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/1Tzkp1SzVk0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>C++: Pointer und Referenzen</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K1) Virtueller Speicher, Segmente: Text, Data, Stack</li> <li>(K2) Pointer sind Variablen, Wert wird als Adresse interpretiert</li> <li>(K2) Pointer als spezielle Variablen: Wert des Pointers als Adresse interpretieren</li> <li>(K2) Initialisierung und Scopes bei Pointern</li> <li>(K3) Zuweisen einer Adresse an einen Pointer</li> <li>(K3) Dereferenzierung eines Pointers und Zugriff auf das referenzierte Element</li> <li>(K3) Pointer als Funktionsparameter: Call-by-Reference mit Hilfe von Pointern</li> <li>(K2) Memory Leaks und Stale Pointer und deren Vermeidung</li> <li>(K3) C++-Operatoren <code>new</code> und <code>delete</code>, Unterschied zu <code>malloc()</code>, <code>free()</code></li> <li>(K3) Referenzen in C++ (Deklaration, Initialisierung, Nutzung)</li> <li>(K3) Zusammenhang und Unterschied Pointer und Arrays</li> <li>(K3) Rechnen mit Pointern, Berücksichtigung des Typs</li></ul>
  </div>
</div>




    <h2 id="virtueller-speicher">Virtueller Speicher</h2>
<pre><code>            +-----------------------------------------+
            |          Text                           | 0x0000
            |                                         |    |
            |-----------------------------------------|    |
            |          Heap (Data)                    |    |
            |                                         |    |
            |--------------------+--------------------|    |
            |                    |                    |    |
            |                    v                    |    |
            |                                         |    |
            |                                         |    v
            |                    ^                    |
            |                    |                    |
            |--------------------+--------------------|
            |                                         |
            |          Stack                          |
            +-----------------------------------------+
</code></pre>
<ul>
<li>Kernel weist jedem Prozess seinen eigenen virtuellen Speicher zu</li>
<li>Linearer Adressbereich, beginnend mit Adresse 0 bis zu einer maximalen Adresse</li>
<li>Verwaltung durch MMU (<em>Memory Management Unit</em>)
<ul>
<li>MMU bildet logische Adressen aus virtuellem Speicher auf den physikalischen Speicher ab</li>
<li>Transparent für den Prozess</li>
</ul>
</li>
</ul>
<h3 id="segmente-des-virtuellen-speichers-text-read-only">Segmente des virtuellen Speichers: Text (read-only)</h3>
<ul>
<li>Programm Code</li>
<li>Konstanten, String Literale</li>
</ul>
<p>zusätzlich (nicht in Abbildung dargestellt):</p>
<ul>
<li>Bereich initialisierter Daten (globale und static Variablen (explizit initialisiert))</li>
<li>Bereich uninitialisierter Daten (globale und static Variablen (uninitialisiert) =&gt; Wert 0)</li>
</ul>
<h3 id="segmente-des-virtuellen-speichers-stack">Segmente des virtuellen Speichers: Stack</h3>
<ul>
<li>Dynamisch wachsend und schrumpfend</li>
<li>Stackframe je Funktionsaufruf:
<ul>
<li>Lokale Variablen (&quot;automatische&quot; Variablen)</li>
<li>Argumente und Return-Werte</li>
</ul>
</li>
<li><strong>Automatische Pflege</strong>
<ul>
<li>Nach Funktionsrückkehr wird der Stackpointer (&quot;Top of Stack&quot;) weiter gesetzt</li>
<li>Dadurch &quot;Bereinigung&quot;: Speicher der lokalen Variablen wird freigegeben</li>
</ul>
</li>
</ul>
<h3 id="segmente-des-virtuellen-speichers-data-heap">Segmente des virtuellen Speichers: Data (Heap)</h3>
<ul>
<li>Dynamisch wachsend und schrumpfend</li>
<li>Bereich für dynamischen Speicher (Allokation während der Laufzeit)</li>
<li>Zugriff und Verwaltung aus <span class='alert'>laufendem</span> Programm =&gt; <strong>Pointer</strong>
<ul>
<li><code>malloc()</code>/<code>calloc()</code>/<code>free()</code> (C)</li>
<li><code>new</code>/<code>delete</code> (C++)</li>
<li>typischerweise <span class='alert'><strong>Pointer</strong></span></li>
</ul>
</li>
<li><strong>KEINE automatische Pflege - Programmierer ist selbst verantwortlich!</strong></li>
</ul>
<h2 id="konzept-eines-pointers">Konzept eines Pointers</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>iptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;  <span style="color:#75715e">/* Wert von iptr ist gleich Adresse von i */</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>iptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;  <span style="color:#75715e">/* Deferenzierung von iptr =&gt; Veränderung von i */</span></span></span></code></pre></div>
<pre><code>        Variable    Speicheraddresse    Inhalt

                                        |          |
                                        +----------+
        i           10125               | 99       |  &lt;--+
                                        +----------+     |
                                        |          |     |
                    ....                 ....            |
                                        |          |     |
                                        +----------+     |
        iptr        27890               | 10125    |  ---+
                                        +----------+
                                        |          |
</code></pre>
<h3 id="pointer-sind-variablen">Pointer sind Variablen</h3>
<ul>
<li>haben Namen und Wert</li>
<li>können mit Operatoren verändert werden</li>
<li>sind einer Speicheradresse im virtuellen Speicher zugeordnet</li>
</ul>
<p>Im Beispiel:</p>
<ul>
<li>Variable <code>i</code>:
<ul>
<li>Name: &quot;i&quot;</li>
<li>Wert: 99</li>
<li>Speicherzelle (Adresse): 10125</li>
</ul>
</li>
<li>Variable <code>iptr</code>:
<ul>
<li>Name: &quot;iptr&quot;</li>
<li>Wert: 10125</li>
<li>Speicherzelle (Adresse): 27890</li>
</ul>
</li>
</ul>
<h3 id="pointer-sind-besondere-variablen">Pointer sind besondere Variablen</h3>
<div class='center'>
<p>Der <span class='alert'>Wert</span> eines Pointers wird als <span class='alert'><strong>Adresse</strong></span> im Speicher behandelt</p>
</div>
<p>Der Wert von <code>iptr</code> ist nicht ein beliebiger Integer, sondern eine Adresse. In
diesem Fall handelt es sich um die Adresse im virtuellen Speicher, wo die
Variable <code>i</code> abgelegt ist.</p>
<p>Wirkung/Interpretation: Variable <code>iptr</code> &quot;zeigt&quot; auf die Adresse von Variable <code>i</code>.</p>
<h3 id="pointer-und-adressen-syntax">Pointer und Adressen (Syntax)</h3>
<ul>
<li>
<p>Deklaration</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Typ <span style="color:#f92672">*</span> Name;</span></span></code></pre></div>
</li>
<li>
<p>Zuweisung einer Adresse über den <code>&amp;</code>-Operator:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>iptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;  <span style="color:#75715e">/* Wert von iptr ist gleich Adresse von i */</span></span></span></code></pre></div>
</li>
<li>
<p><code>iptr</code> ist ein Pointer auf eine (beliebige) Speicherzelle mit Inhalt vom Typ <code>int</code></p>
</li>
<li>
<p>Nach Zuweisung: <code>iptr</code> ist ein Pointer auf die Speicherzelle der Variablen <code>i</code></p>
</li>
</ul>
<h3 id="dereferenzierung-zugriff-auf-ziel">Dereferenzierung: Zugriff auf Ziel</h3>
<ul>
<li>
<p>Dereferenzierung mit <code>*</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>iptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>iptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;  <span style="color:#75715e">// Zugriff auf verwiesene Speicherzelle i
</span></span></span></code></pre></div>
</li>
</ul>
<h3 id="pointer-schreibweisen">Pointer: Schreibweisen</h3>
<ul>
<li>
<p>Position des <code>*</code> zwischen Typ und Name beliebig</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* aequivalente Schreibweisen */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> iptr;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> iptr;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>iptr;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Vorsicht Mehrfachdeklaration */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> iptr, ptr2;      <span style="color:#75715e">/* ptr2 ist nur ein int! */</span></span></span></code></pre></div>
</li>
<li>
<p>Dereferenzierung von Pointern auf Klassen/Structs: Operator <code>-&gt;</code></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* aequivalente Schreibweisen */</span>
</span></span><span style="display:flex;"><span>(<span style="color:#f92672">*</span>iptr).attribut;
</span></span><span style="display:flex;"><span>iptr<span style="color:#f92672">-&gt;</span>attribut;</span></span></code></pre></div>
</li>
</ul>
<h3 id="pointer-zuweisungen-an-andere-pointer">Pointer: Zuweisungen an andere Pointer</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>, <span style="color:#f92672">*</span>iptr, <span style="color:#f92672">*</span>ptr2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ptr2 <span style="color:#f92672">=</span> iptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ptr2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;</span></span></code></pre></div>
<p>Jetzt zeigen zwei Pointer auf die Speicherzelle von Variable <code>i</code>: <code>iptr</code> (wegen <code>iptr = &amp;i</code>), und
weil der Wert von <code>iptr</code> in <code>ptr2</code> kopiert wurde (<code>ptr2 = iptr</code>), zeigt nun auch <code>ptr2</code> auf <code>i</code>.</p>
<p>Der Wert von <code>iptr</code> ist die Adresse von <code>i</code>. Wenn dieser Wert kopiert oder zugewiesen wird, ändert
sich an dieser Adresse nichts. <code>ptr2</code> bekommt diesen Wert zugewiesen, d.h. bei einer Dereferenzierung
von <code>ptr2</code> würde auf die Adresse von <code>i</code> zugriffen werden und dort gelesen/geschrieben werden.</p>
<h3 id="pointer-und-scopes">Pointer und Scopes</h3>
<div class='center'>
<p><span class='alert'><strong>Nicht auf Variablen außerhalb ihres Scopes zugreifen!</strong></span></p>
</div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ip <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>{  <span style="color:#75715e">/* neuer Block */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>    ip <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>j;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;  <span style="color:#75715e">/* AUTSCH!!! */</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">murks</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>i;  <span style="color:#75715e">/* AUTSCH!!! */</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="hotelzimmer-analogie">Hotelzimmer-Analogie</h3>
<ul>
<li>Wenn Sie in ein Hotel einchecken, bekommen Sie den Schlüssel zu <strong>Ihrem</strong> Zimmer
<ul>
<li><em>Pointer</em> == Schlüssel</li>
<li><em>Variable auf die Pointer zeigt</em> == Zimmer</li>
</ul>
</li>
<li>Wenn Sie auschecken, geben Sie normalerweise Ihr Zimmer auf und den Schlüssel ab
<ul>
<li>Pointer wird ungültig</li>
<li>Variable wird ungültig</li>
</ul>
</li>
<li>Wenn Sie beim Auschecken den Schlüssel nicht abgeben, gehört das Zimmer
dennoch nicht mehr Ihnen
<ul>
<li>Sie haben noch den Pointer</li>
<li>Die Variable, auf die der Pointer zeigt, ist ungültig</li>
</ul>
</li>
<li>Wenn Sie jetzt auf das Zimmer gehen, kommen Sie (evtl.) noch rein
<ul>
<li>Evtl. ist das Zimmer noch nicht wieder belegt, und Sie finden Ihr vergessenes Handy</li>
<li>Bei Dereferenzierung erhalten Sie noch den alten Wert der Variablen
<ul>
<li>Evtl. wurde das Zimmer bereits wieder vergeben =&gt; Sie &quot;brechen&quot; bei
einem Fremden ein!</li>
<li>Bei Dereferenzierung greifen Sie auf &quot;fremde&quot; Variablen (Speicherbereiche) zu!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pointer-und-initialisierung">Pointer und Initialisierung</h3>
<div class='center'>
<p>Pointer werden vom Compiler <span class='alert'><strong>nicht</strong></span> initialisiert!</p>
</div>
<ul>
<li>Zeigen ohne explizite Initialisierung auf <span class='alert'><strong>zufällige</strong></span> Adresse</li>
<li>Dereferenzierung uninitialisierter Pointer problematisch</li>
</ul>
<p><strong>Explizite Null-Pointer</strong>:</p>
<ul>
<li>Wert 0 zuweisen</li>
<li>Besser: Symbolische Konstante <code>NULL</code> aus <code>stdio.h</code> bzw. <code>cstdio</code> bzw. in C++ <code>nullptr</code></li>
</ul>
<h2 id="speicherverwaltung">Speicherverwaltung</h2>
<ul>
<li>
<p>C: <span class='alert'><strong>Funktionen</strong></span> zur Verwaltung dynamischen Speichers: <code>malloc()</code>,
<code>free()</code>, ... (in <code>&lt;stdlib.h&gt;</code>)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">size_t</span> size)</span></span></code></pre></div>
<ul>
<li>Alloziert <code>size</code> Bytes auf dem Heap und liefert Adresse zurück</li>
<li>Pointer auf <code>void</code>, da Typ unbekannt - vor Nutzung auf korrekten Typ umcasten</li>
<li>Im Fehlerfall wird ein Null-Pointer zurückgeliefert: <code>NULL</code></li>
<li>Achtung: Speicher ist nicht initialisiert!</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pa <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">free</span>(pa);</span></span></code></pre></div>
</li>
<li>
<p>C++: <span class='alert'><strong>Operatoren</strong></span>: <code>new</code> und <code>delete</code></p>
<ul>
<li>Direkte Angabe des Zieltyps</li>
<li>Rückgabe eines Pointers auf diesen Typ</li>
<li>Exception, wenn kein Speicher verfügbar</li>
<li>Form mit <code>[]</code>-Operator für Arrays</li>
<li>Mit <code>new</code> allozierter Speicher muss mit <code>delete</code> freigegeben werden</li>
<li>Mit <code>new []</code> allozierter Speicher muss mit <code>delete []</code> freigegeben werden</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> [] pa;</span></span></code></pre></div>
</li>
</ul>
<h3 id="speicher-allozieren-standardidiom">Speicher allozieren: Standardidiom</h3>
<p>In C müssen Sie die Rückgabe von <code>malloc</code> prüfen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i, <span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>i <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>x));   <span style="color:#75715e">/* Stern wichtig */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Fehlerbehandlung */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* mach was */</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In C++ bekommen Sie eine Exception, falls <code>new</code> nicht erfolgreich war:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* mach was */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (...) { <span style="color:#75715e">/* Fehlerbehandlung */</span> }</span></span></code></pre></div>
<p><em>Hinweis</em>: Pointer-Variablen <code>i</code> und <code>x</code> liegen auf Stack, angeforderter Speicher im Heap!</p>
<h3 id="pointer-und-typen">Pointer und Typen</h3>
<ul>
<li>Typ eines Zeigers relevant, wird vom Compiler geprüft</li>
<li>Zuweisung ohne expliziten Cast nur an allgemeinere Typen/Oberklassen
<ul>
<li>
<p>Jeder Zeiger auf Typ <code>T</code> kann automatisch zum <code>void</code>-Pointer
konvertiert werden</p>
</li>
<li>
<p>Für Zuweisung von <code>void</code>-Pointern an Pointer auf Typ <code>T</code> expliziter
Cast nach <code>T*</code> nötig (siehe auch nachfolgenden Hinweis zu C11)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>vp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vp <span style="color:#f92672">=</span> cp;          <span style="color:#75715e">/* OK */</span>
</span></span><span style="display:flex;"><span>cp <span style="color:#f92672">=</span> vp;          <span style="color:#75715e">/* problematisch */</span>
</span></span><span style="display:flex;"><span>cp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) vp; <span style="color:#75715e">/* OK */</span></span></span></code></pre></div>
</li>
</ul>
</li>
</ul>
<h3 id="fallstricke-dynamischer-speicherverwaltung">Fallstricke dynamischer Speicherverwaltung</h3>
<h4 id="nur-new-und-delete-kombinieren-bzw-malloc-und-free">Nur new und delete kombinieren bzw. malloc und free</h4>
<ul>
<li>
<p><code>delete</code> darf nur auf mit <code>new</code> erzeugte Objekte angewendet werden</p>
<ul>
<li>Vorsicht bei Pointern auf Stack-Variablen!</li>
<li><span class='alert'><strong>NIE</strong></span> mischen mit <code>malloc()</code>/<code>calloc()</code>/<code>free()</code>!</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;  <span style="color:#75715e">// FEHLER! Absturzgefahr
</span></span></span></code></pre></div>
</li>
</ul>
<h4 id="delete-genau-nur-bei-new">delete[] genau nur bei new[]</h4>
<ul>
<li>
<p><code>delete[]</code> darf nur auf mit <code>new[]</code> erzeugte Objekte angewendet werden
(und <span class='alert'><strong>muss</strong></span> dort auch angewendet werden)</p>
<p><code>delete</code> auf mit <code>new[]</code> erzeugtes Array würde nur
erstes Element freigeben!</p>
</li>
</ul>
<h4 id="vorsicht-mit-pointern-auf-lokale-variablen">Vorsicht mit Pointern auf lokale Variablen</h4>
<ul>
<li>
<p>Funktioniert technisch, ist aber gefährlich:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">murks</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>i;  <span style="color:#75715e">/* SO NICHT: Pointer auf lokale Variable! */</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Etwas besser:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">wenigerMurks</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)); <span style="color:#75715e">/* neuer Speicher */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>p<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p; <span style="color:#75715e">/* das geht */</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<div style="text-align: right;"><span class="badge cstyle default"><span class="badge-content">Warum nur &quot;etwas besser&quot;?</span></span></div>
<p>Jetzt haben Sie aber ein neues Problem: Der Aufrufer der Funktion muss wissen,
dass diese Speicher alloziert und muss sich selbst um die Freigabe kümmern.
Dies ist unschön, da die Allokation und Freigabe in unterschiedlicher
Verantwortung liegen! Dadurch können sehr schnell Fehler passieren.</p>
<p>Besser wäre, wenn der Aufrufer einen Pointer übergibt, mit dem dann in der
Funktion gearbeitet wird. Dann liegt die Verantwortung für die Erstellung und
Freigabe des Pointers komplett in der Hand des Aufrufers.</p>
<h4 id="memory-leaks">Memory Leaks</h4>
<ul>
<li>
<p>Pointer-Variablen unterliegen den Gültigkeitsregeln für Variablen</p>
</li>
<li>
<p>Mit <code>malloc()</code> reservierter Speicher existiert bis Programmende</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i;
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>i));
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* hier existiert die Variable i nicht mehr */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* aber der Speicher auf dem Heap bleibt belegt */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* ist aber nicht mehr zugreifbar -&gt; SPEICHERLOCH! */</span></span></span></code></pre></div>
</li>
</ul>
<h4 id="double-free-und-stale-pointer">Double Free und Stale Pointer</h4>
<ul>
<li><code>free()</code> darf nur <span class='alert'>einmal pro Objekt</span> aufgerufen werden
<ul>
<li>Hintergrund: Intern wird eine Freispeicherliste verwaltet</li>
</ul>
</li>
<li>Nach <code>free()</code> ist der Zeiger undefiniert:
<ul>
<li>Zeigt immer noch in den Heap (alte Adresse!)</li>
<li>Ist nicht gleich <code>NULL</code> oder 0</li>
<li>Zugriff ist möglich, aber gefährlich: Speicher kann wieder vergeben und
überschrieben werden (<em>Hotelzimmer-Analogie</em>)</li>
</ul>
</li>
<li>Mehrere Pointer auf ein Objekt: Einmal <code>free()</code> reicht!
<ul>
<li>Die anderen Pointer dürfen anschließend aber auch nicht mehr
dereferenziert werden (<span class='alert'>stale/dangling pointer</span>)</li>
</ul>
</li>
</ul>
<h4 id="beispiel-stale-pointer">Beispiel Stale Pointer</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i, <span style="color:#f92672">*</span>k; i <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>i)); k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(i);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(i); <span style="color:#75715e">/* EINMAL reicht! */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>; <span style="color:#75715e">/* Speicher ist bereits frei - stale pointer */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(k); <span style="color:#75715e">/* Speicher ist bereits frei - double free */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>; <span style="color:#75715e">/* Speicher ist bereits frei */</span></span></span></code></pre></div>
<p><em>Anmerkung</em>: Anwendung auf <code>NULL</code>-Pointer bewirkt nichts und ist unschädlich</p>
<h4 id="dereferenzieren-von-bad-pointern">Dereferenzieren von &quot;Bad Pointern&quot;</h4>
<p>Der klassische Scanf-Bug :)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, i);</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-1d6f0f83c12e7123caadba29873a1dcb" aria-controls="R-expandcontent-1d6f0f83c12e7123caadba29873a1dcb">
  <label class="expand-label" for="R-expand-1d6f0f83c12e7123caadba29873a1dcb">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-1d6f0f83c12e7123caadba29873a1dcb" class="expand-content">
<p>Tipp: <code>i</code> ist <strong>kein</strong> Pointer :)</p>
  </div>
</div>
<h4 id="auslesen-von-nicht-initialisiertem-speicher">Auslesen von nicht-initialisiertem Speicher</h4>
<p>Wenn Programmierer denken, dass irgendwer den Heap zwischendurch immer mal
wieder auf 0 setzt ...</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* return y = Ax */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">matvec</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>A, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x, <span style="color:#66d9ef">int</span> N) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(N<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            y[i] <span style="color:#f92672">+=</span> A[i][j] <span style="color:#f92672">*</span> x[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-60ed281e43337660633cec8b2efabb0f" aria-controls="R-expandcontent-60ed281e43337660633cec8b2efabb0f">
  <label class="expand-label" for="R-expand-60ed281e43337660633cec8b2efabb0f">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-60ed281e43337660633cec8b2efabb0f" class="expand-content">
<p>Tipp: <code>y[i] += ...</code> setzt sinnvolle Werte in <code>y[i]</code> voraus ...</p>
  </div>
</div>
<h4 id="überschreiben-von-speicher-i">Überschreiben von Speicher I</h4>
<p>Allokation von falschen Größen</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(N<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    p[i] <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(M<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-cc80413b63b35fd624313568cf65f75c" aria-controls="R-expandcontent-cc80413b63b35fd624313568cf65f75c">
  <label class="expand-label" for="R-expand-cc80413b63b35fd624313568cf65f75c">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-cc80413b63b35fd624313568cf65f75c" class="expand-content">
<p>Tipp: Jedes <code>p[i]</code> kann einen <code>int</code> speichern, bekommt aber einen Pointer
zugewiesen (könnte deutlich breiter im Speicher sein als ein <code>int</code>) ...</p>
  </div>
</div>
<h4 id="überschreiben-von-speicher-ii">Überschreiben von Speicher II</h4>
<p>Indexberechnung kaputt, sogenannte &quot;<em>off-by-one-errors</em>&quot;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(N<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    p[i] <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(M<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-7db3b4b8683d20c81e87e796083920d4" aria-controls="R-expandcontent-7db3b4b8683d20c81e87e796083920d4">
  <label class="expand-label" for="R-expand-7db3b4b8683d20c81e87e796083920d4">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-7db3b4b8683d20c81e87e796083920d4" class="expand-content">
<p>Tipp: Hier läuft <code>i</code> um einen Platz zu weit ...</p>
  </div>
</div>
<h4 id="überschreiben-von-speicher-iii">Überschreiben von Speicher III</h4>
<p>Einlesen von Strings, zu kleine Buffer</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">gets</span>(s);</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-a1f1ac03e27a08b431639fbcbe090559" aria-controls="R-expandcontent-a1f1ac03e27a08b431639fbcbe090559">
  <label class="expand-label" for="R-expand-a1f1ac03e27a08b431639fbcbe090559">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-a1f1ac03e27a08b431639fbcbe090559" class="expand-content">
<p>Tipp: Wenn hier mehr als 7 Zeichen eingegeben werden, gibt es Probleme :)</p>
  </div>
</div>
<h4 id="überschreiben-von-speicher-iv">Überschreiben von Speicher IV</h4>
<p>Pointerarithmetik falsch verstanden</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>p <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">!=</span> val)
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="expand">
  <input type="checkbox" id="R-expand-702df0a20511d9f85c1705455855343c" aria-controls="R-expandcontent-702df0a20511d9f85c1705455855343c">
  <label class="expand-label" for="R-expand-702df0a20511d9f85c1705455855343c">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-702df0a20511d9f85c1705455855343c" class="expand-content">
<p>Tipp: Jeder Pointer hat einen Typ, und der Ausdruck &quot;Pointer + 1&quot; rutscht um
so viele Bytes im Speicher weiter, wie der Typ breit ist. D.h. mit einem
&quot;Pointer + 1&quot; gelangt man zum nächsten Element, während der obige Ausdruck
<code>p += sizeof(int);</code> um <code>sizeof(int)</code> Elemente weiterspringt!</p>
  </div>
</div>
<h2 id="pointer-und-arrays">Pointer und Arrays</h2>
<p>Ein Array-Name ist wie ein <em>konstanter</em> Pointer auf Array-Anfang: <code>a[i] == *(a+i)</code></p>
<p>Ein <strong>Array-Name</strong> ist nur ein Label, welches der <strong>Adresse des ersten Array-Elements</strong> entspricht.
Die Wirkung ist entsprechend die eines konstanten Pointers auf den Array-Anfang.</p>
<p>=&gt; Der Compiler übersetzt Array-Zugriffe per Indexoperator in Pointerarithmetik: <code>a[i]</code> wird zu <code>*(a+i)</code> ...</p>
<p>Vgl. auch die Diskussion in
<a href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c" rel="external" target="_blank">eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c</a></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">6</span>], c, <span style="color:#f92672">*</span>cp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&amp;</span>a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> a;
</span></span><span style="display:flex;"><span>cp <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(a<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(cp<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> cp[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> cp;  <span style="color:#75715e">/* FEHLER */</span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c;  <span style="color:#75715e">/* FEHLER */</span></span></span></code></pre></div>
<h3 id="iteration-durch-arrays-varianten">Iteration durch Arrays (Varianten)</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">10</span>], <span style="color:#f92672">*</span>pa<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; k<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; k<span style="color:#f92672">++</span>)    <span style="color:#75715e">/* Iteration, Variante 1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, a[k]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; k<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; k<span style="color:#f92672">++</span>)    <span style="color:#75715e">/* Iteration, Variante 2 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#f92672">*</span>(a<span style="color:#f92672">+</span>k));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pa <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; k<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; k<span style="color:#f92672">++</span>)    <span style="color:#75715e">/* Iteration, Variante 3 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#f92672">*</span>pa<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Iteration, KEINE Variante */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; k<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#f92672">*</span>a<span style="color:#f92672">++</span>);    <span style="color:#75715e">/* DAS GEHT NICHT */</span></span></span></code></pre></div>
<p><code>*pa++</code>: Operator <code>++</code> hat Vorrang vor <code>*</code>, ist aber die Postfix-Variante. D.h.
<code>++</code> wirkt auf <code>pa</code> (und nicht auf <code>*pa</code>), aber zunächst wird für die Ausgabe
<code>*pa</code> ausgewertet ...</p>
<p><code>*a++</code> ist nicht erlaubt, weil dadurch der Name des Arrays (== Adresse des ersten
Array-Elements == konstanter Zeiger auf den Anfang des Arrays) verändert würde.</p>
<h3 id="array-namen-sind-wie-konstante-pointer">Array-Namen sind wie konstante Pointer</h3>
<div class='center'>
<p><span class='alert'><strong>Array-Namen können NICHT umgebogen werden!</strong></span></p>
</div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[], <span style="color:#f92672">*</span>pa<span style="color:#f92672">=</span>a, k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* erlaubt */</span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">+</span> k;
</span></span><span style="display:flex;"><span>pa<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* VERBOTEN */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">++</span>;</span></span></code></pre></div>
<h3 id="selbsttest-was-bedeutet-was-was-ist-erlaubtnicht-erlaubt-was-kommt-raus-warum">Selbsttest: Was bedeutet was, was ist erlaubt/nicht erlaubt, was kommt raus? Warum?</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">10</span>], <span style="color:#f92672">*</span>pa, <span style="color:#f92672">*</span>pb, x;
</span></span><span style="display:flex;"><span>pa <span style="color:#f92672">=</span> a;    pb <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(a<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> pa[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pa<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pa<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> pb[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pb<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pb<span style="color:#f92672">++</span>);</span></span></code></pre></div>
<p>=&gt; Arrays können wie konstante Pointer behandelt werden.</p>
<p>=&gt; Pointer dürfen <span class='alert'><strong>nicht immer wie Arrays</strong></span> behandelt werden!
(Syntaktisch zulässig, semantisch normalerweise nicht!)</p>
<h3 id="pointerarithmetik-typen-beachten">Pointerarithmetik: Typen beachten</h3>
<ul>
<li>Pointer zeigen auf Objekte mit einem bestimmten Typ</li>
<li>Typen haben unterschiedliche Speicherbreite</li>
<li>Inkrementierung/Dekrementierung: Pointer zeigt nicht auf nächste
Speicheradresse, sondern auf die <span class='alert'>Adresse des nächsten Werts</span>!</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> d[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>d1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>d2 <span style="color:#f92672">=</span> d1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d2<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, d2<span style="color:#f92672">-</span>d1);               <span style="color:#75715e">// ergibt 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">long</span>)d2 <span style="color:#f92672">-</span> (<span style="color:#66d9ef">long</span>)d1); <span style="color:#75715e">// double -&gt; zB. 8 Bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">sizeof</span>(d1));  <span style="color:#75715e">// Breite Pointervariable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>d1)); <span style="color:#75715e">// Breite Pointerdatentyp
</span></span></span></code></pre></div>
<h2 id="referenzen-in-c">Referenzen in C++</h2>
<div class='center'>
<p><code>Typ &amp; Name = Objekt;</code></p>
</div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r<span style="color:#f92672">=</span>i;    <span style="color:#75715e">// Referenz: neuer Name fuer i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>r<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;        <span style="color:#75715e">// aendert i: i==10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>r<span style="color:#f92672">=</span>j;         <span style="color:#75715e">// aendert i: i==9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">=</span>r;    <span style="color:#75715e">// aequivalent zu int &amp;s = i;
</span></span></span></code></pre></div>
<h3 id="referenzen-bilden-alias-namen-1">Referenzen bilden Alias-Namen</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>iptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>iref <span style="color:#f92672">=</span> i;   <span style="color:#75715e">// Referenz: neuer Name fuer i
</span></span></span></code></pre></div>
<pre><code>        Variable    Speicheraddresse    Inhalt

                                        |          |
                                        +----------+
        i, iref     10125               | 99       |  &lt;--+
                                        +----------+     |
                                        |          |     |
                    ....                 ....            |
                                        |          |     |
                                        +----------+     |
        iptr        27890               | 10125    |  ---+
                                        +----------+
                                        |          |
</code></pre>
<ul>
<li>Referenz bildet <span class='alert'>Alias-Namen</span> für ein Objekt</li>
<li>Objekt hat damit mehrere Namen, über die es ansprechbar ist</li>
<li>Referenzen in C++ mit Hilfe des <code>&amp;</code>-Operators deklarieren</li>
</ul>
<h3 id="eigenschaften-von-referenzen-in-c">Eigenschaften von Referenzen in C++</h3>
<ul>
<li>
<p>Referenzen müssen bei Deklaration initialisiert werden</p>
</li>
<li>
<p>Referenzen können nicht um-assigned werden</p>
</li>
<li>
<p>Referenzen brauchen keinen eigenen Speicherplatz</p>
</li>
<li>
<p>Vorsicht bei gleichzeitiger Deklaration mehrerer Referenzen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> r<span style="color:#f92672">=</span>i, s<span style="color:#f92672">=</span>j;    <span style="color:#75715e">// SO NICHT!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r<span style="color:#f92672">=</span>i, <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">=</span>j;   <span style="color:#75715e">// korrekt
</span></span></span></code></pre></div>
</li>
</ul>
<h3 id="referenzen-als-funktionsparameter">Referenzen als Funktionsparameter</h3>
<ul>
<li>
<p>Signatur:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">char</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">char</span> b);  <span style="color:#75715e">// a per Referenz
</span></span></span></code></pre></div>
</li>
<li>
<p>Aufruf: ganz normal (ohne extra <code>&amp;</code>) ...</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> y<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>fkt(x, y);  <span style="color:#75715e">// x per Referenz
</span></span></span></code></pre></div>
</li>
</ul>
<p>Im Beispiel werden die Variablen <code>x</code> und <code>y</code> an die Funktion <code>fkt</code> übergeben. Der
erste Parameter wird per Referenz (call-by-reference), der zweite per Kopie
(call-by-value) übergeben.</p>
<p>Der Funktionsparameter <code>a</code> bindet sich an <code>x</code>, ist eine Referenz auf/für <code>x</code> - jeder
Zugriff auf <code>a</code> ist wie ein Zugriff auf <code>x</code>. Änderungen von <code>a</code> sind also Änderungen
von <code>x</code>.</p>
<p>Der zweite Parameter bindet sich an den <em>Wert</em> von <code>y</code>, d.h. <code>b</code> hat den Wert <code>'a'</code>.
Zwar kann auch <code>b</code> verändert werden, das hat dann aber nur Auswirkungen innerhalb der
Funktion und nicht auf die Variable <code>y</code> im äußeren Scope.</p>
<h2 id="call-by-reference-semantik-in-c">Call-by-Reference Semantik in C++</h2>
<h3 id="variante-a-pointer-c-und-c">Variante A: Pointer (C und C++)</h3>
<p>Mit Hilfe von Pointern lässt sich die Call-by-Reference Semantik in C und in C++ simulieren.</p>
<p>Bei der Übergabe eines Pointers wird der Wert des Pointers <em>kopiert</em> (call-by-value!). Im Inneren
der Funktion kann diese Adresse dereferenziert werden und so auf das außerhalb der Funktion &quot;lebende&quot;
Objekt zugegriffen werden. Damit bekommt man in der Wirkung call-by-reference.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_5</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">*</span>ip<span style="color:#f92672">=&amp;</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_5</span>(ip);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_5</span>(<span style="color:#f92672">&amp;</span>i);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Pointer wird nach wie vor per <span class='alert'>call-by-value</span> übergeben:
<ul>
<li>Wert wird bei Übergabe <span class='alert'>kopiert</span> (hier Adresse von <code>i</code>)</li>
<li>Kopierter Wert ist immer noch ein Pointer (hier Pointer auf <code>i</code>, da
Adresse von <code>i</code>)</li>
<li>Dereferenzierung des kopierten Pointers: Zugriff auf das
Original-Objekt (hier <code>i</code>)</li>
</ul>
</li>
</ul>
<h3 id="variante-b-referenzen-nur-c">Variante B: Referenzen (nur C++)</h3>
<p>Referenzen müssen bei der Deklaration initialisiert werden und binden sich an das dabei genutzte
Objekt. Sie stellen letztlich lediglich einen neuen Namen für das Objekt dar.</p>
<p>Bei der Übergabe von Variablen an Referenz-Parameter einer Funktion binden sich diese Parameter an
die übergebenen Objekte. Jeder Zugriff innerhalb der Funktion auf einen Referenz-Parameter bewirken
einen Zugriff auf das ursprüngliche Objekt.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add_5</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x) {
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, erg;
</span></span><span style="display:flex;"><span>    erg <span style="color:#f92672">=</span> add_5(i);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Funktionsparameter <code>x</code> ist eine Referenz</li>
<li>Bei Aufruf der Funktion wird dieser Parameter initialisiert - die Referenz <code>x</code> bindet sich
im Beispiel an die Variable <code>i</code></li>
<li>Zugriffe auf <code>x</code> in der Funktion sind also Zugriffe auf das Original-Objekt <code>i</code> - <code>x += 5</code>
ist nichts anderes als <code>i += 5</code></li>
<li>Bei weiteren Aufrufen wird <code>x</code> dann neu gebunden</li>
</ul>
<h3 id="call-by-reference-const">Call-by-Reference: const</h3>
<ul>
<li>
<p>Nachteil bei Call-by-Reference:</p>
<p>Übergebenes Objekt könnte durch die Funktion (unbeabsichtigt) verändert werden</p>
</li>
<li>
<p>Abhilfe: Deklaration der Parameter als konstant (Schlüsselwort <code>const</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">char</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">char</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// a wird per Referenz uebergeben, darf aber in der Funktion nicht veraendert werden
</span></span></span></code></pre></div>
</li>
</ul>
<p>=&gt; <code>const</code>-heit ist Bestandteil der Signatur!</p>
<div class='center'>
<p><span class='alert'><strong>Arbeiten Sie (wo möglich/sinnvoll) mit (konstanten) Referenzen!</strong></span></p>
</div>
<h3 id="rückgabe-von-werten-per-referenz">Rückgabe von Werten per Referenz</h3>
<ul>
<li>Normalerweise per call-by-value (Kopie)</li>
<li>Mit Referenzen oder Pointern auch als call-by-reference</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>fkt1(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fkt2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>);</span></span></code></pre></div>
<ul>
<li>
<p>Vorsicht mit lokalen Variablen (Gültigkeit)!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>fkt1(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>j) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> erg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> erg;   <span style="color:#75715e">// Referenz auf lokale Variable!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fkt2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>j) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> erg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>erg;  <span style="color:#75715e">// Pointer auf lokale Variable!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x <span style="color:#f92672">=</span> fkt1(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;a&#34;</span>);  <span style="color:#75715e">// AUTSCH!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> fkt2(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;b&#34;</span>);  <span style="color:#75715e">// AUTSCH!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>  z <span style="color:#f92672">=</span> fkt1(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;c&#34;</span>);  <span style="color:#75715e">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
</li>
</ul>
<p>Die Zuweisung <code>int &amp;x = fkt1(2, &quot;a&quot;);</code> ist syntaktisch erlaubt. Semantisch aber nicht: Die
Referenz <code>x</code> bindet sich an das zurückgelieferte lokale <code>erg</code> - dieses existiert aber nicht
mehr, da der Scope von erg beendet ist ...</p>
<p><strong>=&gt; Nur Pointer auf Speicher zurückliefern, der nach Beendigung des Funtionsaufrufes noch existiert!</strong>
(Dies könnte beispielsweise Speicher aus <code>malloc</code> oder <code>new</code> oder ein Pointer auf das eigene Objekt
(<code>*this</code>) sein.)</p>
<p>Die Zuweisung <code>int *y = fkt2(2, &quot;b&quot;);</code> ist syntaktisch erlaubt. Semantisch aber nicht: Der
Pointer <code>y</code> übernimmt die zurückgelieferte Adresse des lokalen <code>erg</code> - dieses existiert aber
nicht mehr, da der Scope von erg beendet ist ...</p>
<p><strong>=&gt; Nur Referenzen zurückliefern, die nach Beendigung des Funtionsaufrufes noch gültig sind!</strong>
(Dies könnten beispielsweise Referenz-Inputparameter oder eine Referenz auf das eigene Objekt
(<code>*this</code>) sein.)</p>
<p>Die Zuweisung <code>int  z = fkt1(2, &quot;c&quot;);</code> ist unbedenklich, da <code>z</code> eine normale Integervariable
ist und hier das übliche Kopieren der Rückgabe von <code>ftk1</code> in die Variable stattfindet.</p>
<h3 id="diskussion">Diskussion</h3>
<p>In C++ können Sie Call-by-Reference über Pointer und/oder über Referenzen erreichen.</p>
<p>In den obigen Beispielen wurde dies für die Parameter einer Funktion gezeigt - es sind
aber auch Pointer und/oder Referenzen als Rückgabetypen möglich. Beachten Sie dabei,
ob das jeweils wirklich Sinn ergibt! Eine Referenz oder ein Pointer auf eine lokale
Variable ist eine große Fehlerquelle.</p>
<p>In C++ werden Referenzen über Pointer bevorzugt. Wenn Sie die Wahl zwischen den beiden
Signaturen <code>bar foo(wuppie&amp;,  bar)</code> und <code>bar foo(wuppie*,  bar)</code> haben, sollten Sie sich
für <code>bar foo(wuppie&amp;,  bar)</code> entscheiden.</p>
<h2 id="vergleich-pointer-mit-referenzen">Vergleich Pointer mit Referenzen</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Referenzen</th>
          <th style="text-align: left">Pointer</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">Alias-Name für Objekte/Variablen, kein eigener Speicherplatz</td>
          <td style="text-align: left">&quot;Echte&quot; Variablen mit eigenem Speicherplatz (für den Wert des Pointers)</td>
      </tr>
      <tr>
          <td style="text-align: left">Können nicht auf andere Objekte &quot;umgebogen&quot; werden</td>
          <td style="text-align: left">Können auf andere Objekte zeigen (falls nicht const)</td>
      </tr>
      <tr>
          <td style="text-align: left">Operationen agieren direkt auf dem referenzierten Objekt</td>
          <td style="text-align: left">Operationen auf referenzierten Objekt als auch auf dem Pointer selbst</td>
      </tr>
      <tr>
          <td style="text-align: left">Nur in C++</td>
          <td style="text-align: left">In C und in C++</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">Mit Pointern ist dynamische Speicherverwaltung möglich: Manipulation von Speicherbereichen im Heap</td>
      </tr>
  </tbody>
</table>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Virtueller Speicher: Kernel stellt Prozessen linearen Adressraum bereit,
Segmente: Text, Stack, Heap</p>
</li>
<li>
<p>Pointer sind Variablen, deren <strong>Wert als Adresse</strong> interpretiert wird</p>
<ul>
<li>Deklaration mit <code>*</code> zwischen Typ und Name</li>
<li>Adressoperator <code>&amp;</code> liefert die Adresse eines Objekts</li>
<li>Dereferenzierung eines Pointers mit <code>*</code> vor dem Namen</li>
</ul>
</li>
<li>
<p>Verwandtschaft zw. Arrays und Pointern: Array-Name ist konstanter Pointer auf Array-Anfang</p>
</li>
<li>
<p>Pointer haben Typ: Pointerarithmetik berücksichtigt Speicherbreite des Typs</p>
</li>
<li>
<p>C++-Referenzen als Alias-Namen für ein Objekt</p>
<ul>
<li>Deklaration: <code>Typ &amp;ref = obj;</code></li>
<li>Fest mit Objekt verbunden</li>
<li>Zugriff auf Referenz: Direkter Zugriff auf das Objekt</li>
</ul>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Pointer</strong></p>
<ul>
<li>
<p>Erklären Sie das Problem bei folgender Deklaration: <code>int* xptr, yptr;</code></p>
</li>
<li>
<p>Seien <code>p1</code> und <code>p2</code> Pointer auf <code>int</code>. Was ist der Unterschied zwischen den
beiden Code-Zeilen?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>p2  <span style="color:#f92672">=</span> p1;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p1;</span></span></code></pre></div>
</li>
<li>
<p>Ist <code>*&amp;x</code> immer identisch mit <code>x</code>?</p>
</li>
<li>
<p>Ist <code>&amp;*x</code> immer identisch mit <code>x</code>?</p>
</li>
<li>
<p>Wann kann die Funktion <code>void f(int*)</code> so aufgerufen werden: <code>f(&amp;x);</code>?</p>
</li>
</ul>
<p><strong>Swap ...</strong></p>
<ul>
<li>
<p>Warum funktioniert die folgende <code>swap()</code>-Funktion nicht?
Wie müsste sie korrigiert werden?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp; tmp<span style="color:#f92672">=</span>x; x<span style="color:#f92672">=</span>y; y<span style="color:#f92672">=</span>tmp;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Was ist mit dieser Version dieser <code>swap()</code>-Funktion?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>    tmp<span style="color:#f92672">=</span>x; x<span style="color:#f92672">=</span>y; y<span style="color:#f92672">=</span>tmp;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<p><strong>C++: new und delete</strong></p>
<p>Betrachten Sie folgende Code-Schnipsel.
Erklären Sie die Wirkung der jeweiligen Anweisungen.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    cp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> cp;
</span></span><span style="display:flex;"><span>    free(cp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;</span></span></code></pre></div>
<p><strong>Referenzen vs. Pointer: Welche der Aufrufe sind zulässig?</strong></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f1</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f2</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">*</span>ip<span style="color:#f92672">=&amp;</span>i, <span style="color:#f92672">&amp;</span>ir<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f1(i);      f1(<span style="color:#f92672">&amp;</span>i);     f1(<span style="color:#f92672">*</span>i);
</span></span><span style="display:flex;"><span>    f1(ip);     f1(<span style="color:#f92672">&amp;</span>ip);    f1(<span style="color:#f92672">*</span>ip);
</span></span><span style="display:flex;"><span>    f1(ir);     f1(<span style="color:#f92672">&amp;</span>ir);    f1(<span style="color:#f92672">*</span>ir);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f2(i);      f2(<span style="color:#f92672">&amp;</span>i);     f2(<span style="color:#f92672">*</span>i);
</span></span><span style="display:flex;"><span>    f2(ip);     f2(<span style="color:#f92672">&amp;</span>ip);    f2(<span style="color:#f92672">*</span>ip);
</span></span><span style="display:flex;"><span>    f2(ir);     f2(<span style="color:#f92672">&amp;</span>ir);    f2(<span style="color:#f92672">*</span>ir);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><strong>C++-Referenzen und Pointer</strong></p>
<p>Betrachten Sie folgende Code-Schnipsel.
Erklären Sie die Wirkung der jeweiligen Anweisungen.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">&amp;</span>y<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ptr1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ptr1<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ptr2  <span style="color:#f92672">=</span> ptr1;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ptr2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>ptr1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ptr1  <span style="color:#f92672">==</span> ptr2;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ptr1 <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>ptr2;</span></span></code></pre></div>
<p><strong>Fallstricke mit C++-Referenzen</strong></p>
<p>Betrachten Sie folgende Code-Ausschnitte. Welchen Wert haben die Variablen nach
der Ausführung? Begründen Sie Ihre Antwort.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r<span style="color:#f92672">=</span>i, <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">=</span>r;
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">=</span><span style="color:#ae81ff">200</span>;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> erg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> erg;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>z <span style="color:#f92672">=</span> versuch(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><strong>Referenzen in C++</strong></p>
<p>Betrachten Sie folgende Code-Ausschnitte (C++). Erklären Sie, ob sich dort
Fehler verstecken und falls ja, wie diese zu beheben wären.</p>
<ol>
<li>
<p>Versuch</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, b<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>z <span style="color:#f92672">=</span> versuch(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>erg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> erg;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Versuch</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, b<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>z <span style="color:#f92672">=</span> versuch(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> erg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> erg;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
<li>
<p>Versuch</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, b<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>z <span style="color:#f92672">=</span> versuch(a, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>versuch(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j) {
</span></span><span style="display:flex;"><span>    j <span style="color:#f92672">+=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> j;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ol>
<p><strong>Pointer und Arrays</strong></p>
<ul>
<li>
<p>Erklären Sie die Unterschiede folgender Anweisungen. Welche sind
erlaubt, welche nicht? Welche führen möglicherweise zu Fehlern?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">10</span>], <span style="color:#f92672">*</span>pa, <span style="color:#f92672">*</span>pb, x;
</span></span><span style="display:flex;"><span>pa <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(a<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> pa[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pa<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pa<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> pb[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pb<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(pb<span style="color:#f92672">++</span>);</span></span></code></pre></div>
</li>
</ul>
<p><strong>Typ eines Pointers bei Adressarithmetik</strong></p>
<ul>
<li>
<p>Was ist der Unterschied zwischen den beiden folgenden Statements?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)ptr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>((<span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>)ptr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span></span></span></code></pre></div>
</li>
</ul>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Klassen</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Klassen werden in C++ mit dem Schlüsselwort <code>class</code> definiert. Dabei müssen Klassendefinitionen immer
mit einem Semikolon abgeschlossen werden(!). Bei Trennung von Deklaration und Implementierung muss die
Definition der Methoden mit dem Namen der Klasse als Namespace erfolgen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// .h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fluppie</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> wuppie(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// .cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> Fluppie<span style="color:#f92672">::</span>wuppie(<span style="color:#66d9ef">int</span> c) { ... }</span></span></code></pre></div>
<p>Die Sichtbarkeiten für die Attribute und Methoden werden blockweise definiert. Für die Klassen selbst
gibt es keine Einstellungen für die Sichtbarkeit.</p>
<p>Objekt-Layout: Die Daten (Attribute) liegen direkt im Objekt (anderenfalls Pointer nutzen). Sofern der
Typ der Attribute eine Klasse ist, kann man diese Attribute nicht mit <code>NULL</code> initialisieren (kein Pointer,
keine Referenz).</p>
<p>Für den Aufruf eines Konstruktors ist kein <code>new</code> notwendig, es sei denn, man möchte das neue Objekt
auf dem Heap haben (inkl. Pointer auf das Objekt).</p>
<p>Beachten Sie den Unterschied der Initialisierung der Attribute bei einer Initialisierung im Body des
Konstruktors vs. der Initialisierung über eine <strong>Initialisierungsliste</strong>. (Nutzen Sie in C++ nach
Möglichkeit Initialisierungslisten.)</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/4xAYFHWvBGc' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL C++: Klassen</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Attribute von C++-Klassen sind Speicherplatz im Objekt</li> <li>(K2) Explizite Konstruktoren</li> <li>(K2) Problematik mit Defaultkonstruktoren/-operatoren (Pointer)</li> <li>(K3) Konstruktoren (eigene, Default)</li> <li>(K3) Unterschied Initialisierungslisten vs. Initialisierung im Body</li></ul>
  </div>
</div>




    <h2 id="oop-in-c">OOP in C++</h2>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Dummy</span>(<span style="color:#66d9ef">int</span> v) { value <span style="color:#f92672">=</span> v; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">myMethod</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">myMethod</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Dummy();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
</div>
</div>
<h3 id="oop-in-c-unterschiede-zu-java">OOP in C++: Unterschiede zu Java</h3>
<ul>
<li>Klassendefinition muss mit Semikolon beendet werden</li>
<li>Sichtbarkeit wird immer blockweise eingestellt (per Default immer <code>private</code>)</li>
<li>Wie bei Funktionen: Deklaration muss vor Verwendung (= Aufruf) bekannt sein</li>
<li><code>this</code> ist keine Referenz, sondern ein <strong>Pointer</strong> auf das eigene Objekt</li>
</ul>
<h3 id="objektlayout-java-vs-c">Objektlayout: Java vs. C++</h3>
<h4 id="java-referenzen-auf-objekte">Java: Referenzen auf Objekte</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span>    String name;
</span></span><span style="display:flex;"><span>    Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><a href="#R-image-6eddb07286cec21c653165e9b8b8d3f1" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp2-classes/objektLayoutJava.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6eddb07286cec21c653165e9b8b8d3f1"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp2-classes/objektLayoutJava.png?width=auto&height=auto"></a></p>
<p>In Java werden im Objektlayout lediglich die primitiven Attribute direkt gespeichert.</p>
<p>Für Objekte wird nur eine Referenz auf die Objekte gehalten. Die Attribute selbst
liegen aber außerhalb der Klasse, dadurch benötigt das Objekt selbst nur relativ wenig
Platz im Speicher.</p>
<h4 id="c-alles-direkt-im-objekt">C++: Alles direkt im Objekt</h4>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span>    string name;
</span></span><span style="display:flex;"><span>    Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><a href="#R-image-fd739e00a80362fb10ef7908ba811c47" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp2-classes/objektLayoutCpp.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fd739e00a80362fb10ef7908ba811c47"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp2-classes/objektLayoutCpp.png?width=auto&height=auto"></a></p>
<p>In C++ werden alle Attribute innerhalb des Objektlayouts gespeichert. Ein Objekt mit
vielen oder großen Feldern braucht also auch entsprechend viel Platz im Speicher.</p>
<p>Wollte man eine Java-ähnliche Lösung aufbauen, müsste man in C++ entsprechend Pointer
einsetzen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>    Date <span style="color:#f92672">*</span>birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><span class='alert'><strong>Warum nicht Referenzen?</strong></span></p>
<h2 id="objekte-erzeugen-mit-konstruktoren">Objekte erzeugen mit Konstruktoren</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) { credits <span style="color:#f92672">=</span> c; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><strong>Erzeugen neuer Objekte</strong>:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy a;
</span></span><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">b</span>(<span style="color:#ae81ff">37</span>);
</span></span><span style="display:flex;"><span>Dummy c<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>;</span></span></code></pre></div>
<p><span class='alert'><strong>=&gt; Kein Aufruf von <code>new</code>!</strong></span></p>
<p>(<code>new</code> würde zwar auch ein neues Objekt anlegen, aber <strong>auf dem Heap</strong>!)</p>
<h2 id="default-konstruktoren">Default-Konstruktoren</h2>
<p>Der C++-Compiler generiert einen <strong>parameterlosen Defaultkonstruktor</strong> - sofern man
nicht selbst mindestens einen Konstruktor definiert.</p>
<p>Dieser parameterlose Defaultkonstruktor wendet für jedes Attribut dessen parameterlosen
Konstruktor an, für primitive Typen erfolgt keine garantierte Initialisierung!</p>
<p><span class='alert'><strong>Achtung</strong></span>: Default-Konstruktor wird ohne Klammern aufgerufen!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy a;    <span style="color:#75715e">// Korrekt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Dummy <span style="color:#a6e22e">a</span>();  <span style="color:#75715e">// FALSCH!!! (Deklaration einer Funktion `a()`, die ein `Dummy` zurueckliefert)
</span></span></span></code></pre></div>
<h2 id="c-trennung-h-und-cpp">C++: Trennung .h und .cpp</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// .h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// .cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Dummy<span style="color:#f92672">::</span>Dummy(<span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>    credits <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Klassenname ist der Scope für die Methoden</p>
<h2 id="konstruktoren-normale-java-like-initialisierung">Konstruktoren: Normale (Java-like) Initialisierung</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Student(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>n, <span style="color:#66d9ef">const</span> Date <span style="color:#f92672">&amp;</span>d, <span style="color:#66d9ef">double</span> c) {
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>        birthday <span style="color:#f92672">=</span> d;
</span></span><span style="display:flex;"><span>        credits <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string name;
</span></span><span style="display:flex;"><span>    Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Hier erfolgt die Initialisierung in <strong>zwei</strong> Schritten:</p>
<ol>
<li>Attribut wird angelegt und mit <span class='alert'>Defaultwert/-konstruktor</span> des Datentyps initialisiert</li>
<li><span class='alert'>Anschließend</span> wird die <span class='alert'>Zuweisung</span> im Body des Konstruktors ausgeführt</li>
</ol>
<p>Das klappt natürlich nur, wenn es einen parameterlosen Konstruktor für das Attribut
gibt.</p>
<p>Beispiel oben:
Beim Anlegen von <code>birthday</code> im Speicher wird der <strong>Defaultkonstruktor</strong> für
<code>Date</code> aufgerufen. Danach wird im Body der übergebene Datumswert <strong>zugewiesen</strong>.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/studiInitBody.cpp" target="_blank"><span class="title">Konsole: studiInitBody.cpp</span></a></span></div>
<h2 id="konstruktoren-initialisierungslisten">Konstruktoren: Initialisierungslisten</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Student(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>n, <span style="color:#66d9ef">const</span> Date <span style="color:#f92672">&amp;</span>d, <span style="color:#66d9ef">double</span> c)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> name(n), birthday(d), credits(c)
</span></span><span style="display:flex;"><span>    {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string name;
</span></span><span style="display:flex;"><span>    Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>In diesem Fall erfolgt die Initialisierung in nur einem Schritt:</p>
<ol>
<li>Attribut wird angelegt und <span class='alert'>direkt</span> mit übergebenen Wert
(<span class='alert'>Kopie</span>) initialisiert</li>
</ol>
<p>Das klappt natürlich nur, wenn ein passender Konstruktor für das Attribut
existiert.</p>
<p><strong>Achtung</strong>: Die Reihenfolge der Auswertung der Initialisierungslisten wird durch
die Reihenfolge der Attribut-Deklarationen in der Klasse bestimmt!!!</p>
<p>Beispiel oben:
Beim Anlegen von <code>birthday</code> im Speicher wird direkt der übergebene Wert <strong>kopiert</strong>.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/studiInitListe.cpp" target="_blank"><span class="title">Konsole: studiInitListe.cpp (ohne/mit <code>-Wall</code>)</span></a></span></div>
<h2 id="zwang-zu-initialisierungslisten">Zwang zu Initialisierungslisten</h2>
<p>In manchen Fällen <strong>muss</strong> man die Initialisierung der Attribute per
Initialisierungsliste durchführen.</p>
<p>Hier einige Beispiele:</p>
<ul>
<li>
<p>Attribut <strong>ohne parameterfreien Konstruktor</strong></p>
<p>Bei &quot;normaler&quot; Initialisierung würde zunächst der parameterfreie Konstruktor für das
Attribut aufgerufen, bevor der Wert zugewiesen wird. Wenn es keinen parameterfreien
Konstruktor für das Attribut gibt, bekommt man beim Kompilieren einen Fehler.</p>
</li>
<li>
<p><strong>Konstante</strong> Attribute</p>
<p>Bei &quot;normaler&quot; Initialisierung würde das Attribut zunächst per parameterfreiem Konstruktor
angelegt (s.o.), danach existiert es und ist konstant und darf nicht mehr geändert werden
(müsste es aber, um die eigentlich gewünschten Werte im Body zu setzen) ...</p>
</li>
<li>
<p>Attribute, die <strong>Referenzen</strong> sind</p>
<p>Referenzen müssen direkt beim Anlegen initialisiert werden.</p>
</li>
</ul>
<h2 id="c11-und-delegierende-konstruktoren">C++11 und delegierende Konstruktoren</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1: Normaler Konstruktor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C(<span style="color:#66d9ef">int</span> x) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2: Delegiert zu (1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C() <span style="color:#f92672">:</span> C(<span style="color:#ae81ff">42</span>) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3: Rekursion mit (4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C(<span style="color:#66d9ef">char</span> c) <span style="color:#f92672">:</span> C(<span style="color:#ae81ff">42.0</span>) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 4: Rekursion mit (3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C(<span style="color:#66d9ef">double</span> d) <span style="color:#f92672">:</span> C(<span style="color:#e6db74">&#39;a&#39;</span>) { }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Delegierende Konstruktoren gibt es ab C++11:</p>
<ul>
<li>Vor C++11: Ein Objekt ist fertig konstruiert, wenn der Konstruktor durchgelaufen ist</li>
<li>Ab C++11: Ein Objekt ist fertig konstruiert, wenn der <strong>erste</strong> Konstruktor fertig
ausgeführt ist
=&gt; Jeder weitere aufgerufene Konstruktor agiert auf einem &quot;fertigen&quot; Objekt.</li>
<li>Vorsicht mit rekursiven Aufrufen: Compiler <em>kann</em> warnen, muss aber nicht.</li>
</ul>
<h2 id="c-und-explizite-konstruktoren">C++ und explizite Konstruktoren</h2>
<ul>
<li>
<p>Implizite Konvertierung mit einelementigen Konstruktoren:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Dummy a;
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">37</span>;     <span style="color:#75715e">// Zuweisung(!)
</span></span></span></code></pre></div>
<p>Auf der linken Seite der Zuweisung steht der Typ <code>Dummy</code>, rechts ein <code>int</code>.
Der Compiler sucht nach einem Weg, aus einem <code>int</code> einen <code>Dummy</code> zu machen
und hat durch die Gestaltung des Konstruktors von <code>Dummy</code> diese Möglichkeit.
D.h. in dieser Zuweisung wird implizit aus der 37 ein Objekt vom Typ <code>Dummy</code>
gebaut (Aufruf des Konstruktors) und dann die Zuweisung ausgeführt.</p>
<p>Dieses Verhalten ist in vielen Fällen recht praktisch, kann aber auch zu
unerwarteten Problemen führen. Zur Abhilfe gibt es das Schlüsselwort <code>explicit</code>.</p>
</li>
<li>
<p>Falls unerwünscht: Schlüsselwort <code>explicit</code> nutzen</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">Dummy</span>(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Klassendefinition mit Semikolon abschließen (!)</li>
<li>Sichtbarkeiten blockweise, keine für Klasse</li>
<li>Daten liegen direkt im Objekt (anderenfalls Pointer nutzen)</li>
<li>Attribute sind echte Objekte: Initialisieren mit <code>NULL</code> nicht möglich</li>
<li>Konstruktoren: Kein <code>new</code> nötig (würde Objekt auf Heap anlegen und Pointer liefern)</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>C++: Klassen</strong></p>
<p>Erklären Sie die Unterschiede zwischen den Klassendefinitionen (Java, C++):</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string name;
</span></span><span style="display:flex;"><span>    Date birthday;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><strong>Konstruktoren</strong></p>
<ul>
<li>Wie kann der implizite Aufruf eines Konstruktors verhindert werden
(beispielsweise in <code>Dummy b; b=3;</code>)?</li>
<li>In welchen Fällen muss eine Initialisierung von Attributen in der
Initialisierungsliste stattfinden?</li>
<li>Wie können/müssen <code>static</code> Attribute initialisiert werden?</li>
</ul>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Big 3</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Für C++-Klassen kann man Destruktoren, Copy-Konstruktoren und Zuweisungsoperatoren definieren.
Wenn man keine eigenen definiert, erzeugt C++ Default-Varianten. Diese bereiten u.U. Probleme,
wenn man Pointertypen für die Attribute verwendet: Dann werden u.U. nur flache Kopien erzeugt
bzw. es wird u.U. der Platz auf dem Heap nicht freigegeben.</p>
<p>Der Default-Destruktor ruft die Destruktoren der Objekt-Attribute auf. Der Copy-Konstruktor wird
aufgerufen, wenn die linke Seite (einer scheinbaren &quot;Zuweisung&quot;) ein unfertiges Objekt ist (noch
zu bauen) und die rechte Seite ein fertiges Objekt ist. Der Zuweisungs-Operator wird dagegen
aufgerufen, wenn auf beiden Seiten ein fertiges Objekt vorliegt.</p>
<p>Innerhalb einer Klasse kann man über den <strong>Pointer <code>this</code></strong> auf das eigene Objekt zugreifen
(analog zu <code>self</code> in Python oder <code>this</code> in Java, dort aber Referenzen).</p>
<p>Bei statischen Methoden und Attributen wird die Deklaration als <code>static</code> <strong>nicht</strong> in der
Implementierung wiederholt! Statische Attribute müssen außerhalb der Klassendefinition einmal
initialisiert werden!</p>
<p>Methoden können als &quot;konstant&quot; ausgezeichnet werden (<code>const</code> rechts von der Parameterliste). Das
<code>const</code> gehört zur Signatur der Methode! Konstante Methoden dürfen auf konstanten Objekten/Referenzen
aufgerufen werden.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/PaBK04Jks58' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL C++: Big 3</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Problematik mit Defaultkonstruktoren/-operatoren (Pointer)</li> <li>(K2) Problematik konstanter Funktionen, wann werden diese aufgerufen</li> <li>(K3) 'Big Three': Destruktor, Copy-Konstruktor, Zuweisungsoperator</li></ul>
  </div>
</div>




    <h2 id="big-three">Big Three</h2>
<p>Neben dem eigentlichen Konstruktor existieren in C++ weitere wichtige Konstruktoren/Operatoren:
die sogenannten <span class='alert'>&quot;Big Three&quot;</span>:</p>
<ul>
<li>Copy-Konstruktor</li>
<li>Destruktor: Gegenstück zum Konstruktor</li>
<li>Zuweisungsoperator (<code>operator=</code>)</li>
</ul>
<p><em>Anmerkung</em>: Für Fortgeschrittenere sei hier auf die in C++11 eingeführte und den Folgeversionen verbesserte und
verfeinerte <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors" rel="external" target="_blank">Move-Semantik</a> und
die entsprechenden Varianten der Konstruktoren und Operatoren verwiesen. Man spricht deshalb mittlerweile auch gern
von den &quot;Big Five&quot; bzw. der <a href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)" rel="external" target="_blank">&quot;rule of five&quot;</a>.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>d);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Dummy();
</span></span><span style="display:flex;"><span>    Dummy <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>d);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy<span style="color:#f92672">::</span>Dummy(<span style="color:#66d9ef">int</span> a)<span style="color:#f92672">:</span> value(a) {}
</span></span><span style="display:flex;"><span>Dummy<span style="color:#f92672">::</span>Dummy(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>d)<span style="color:#f92672">:</span> value(d.value) {}
</span></span><span style="display:flex;"><span>Dummy<span style="color:#f92672">::~</span>Dummy() {}
</span></span><span style="display:flex;"><span>Dummy<span style="color:#f92672">::</span>Dummy <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>d) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>d) { value <span style="color:#f92672">=</span> d.value; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="big-three-destruktor">Big Three: Destruktor</h3>
<ul>
<li>Syntax: <code>Dummy::~Dummy();</code>
(Konstruktor mit vorgesetzter Tilde)</li>
<li>Wird aufgerufen:
<ul>
<li>wenn ein Objekt seinen Scope verlässt, oder</li>
<li>wenn explizit <code>delete</code> für einen Pointer auf ein Objekt (auf dem Heap!) aufgerufen wird</li>
</ul>
</li>
<li>Default-Destruktor ruft Destruktoren der Objekt-Attribute auf</li>
</ul>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/destruktor.cpp" target="_blank"><span class="title">Konsole: destruktor.cpp</span></a></span></div>
<h3 id="big-three-copy-konstruktor">Big Three: Copy-Konstruktor</h3>
<ul>
<li>Syntax: <code>Dummy::Dummy(const Dummy &amp;);</code></li>
<li>Wird aufgerufen bei:
<ul>
<li>Deklaration mit Initialisierung mit Objekt</li>
<li>Objektübergabe und -rückgabe mit Call-by-Value</li>
<li><span class='alert'>Nicht bei Zuweisung</span></li>
</ul>
</li>
<li>Default-Copy-Konstruktor kopiert einfach elementweise
=&gt; bei Pointern also nur <strong>flache Kopie</strong></li>
</ul>
<p>&quot;<strong>Merkregel</strong>&quot;: Linke Seite unfertiges Objekt (noch zu bauen), rechte Seite fertiges Objekt.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/copyKonstruktor.cpp" target="_blank"><span class="title">Konsole: copyKonstruktor.cpp</span></a></span></div>
<h3 id="big-three-zuweisungsoperator">Big Three: Zuweisungsoperator</h3>
<ul>
<li>Syntax: <code>Dummy &amp;Dummy::operator=(const Dummy &amp;)</code></li>
<li>Wird aufgerufen:
<ul>
<li>bei Zuweisung bereits initialisierter Objekte</li>
</ul>
</li>
<li>Default-Zuweisungsoperator kopiert einfach elementweise
=&gt; bei Pointern also nur <strong>flache Kopie</strong></li>
</ul>
<p>&quot;<strong>Merkregel</strong>&quot;: Linke Seite fertiges Objekt, rechte Seite fertiges Objekt.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/zuweisungsOperator.cpp" target="_blank"><span class="title">Konsole: zuweisungsOperator.cpp</span></a></span></div>
<h3 id="big-three-defaults">Big Three: Defaults</h3>
<p>Analog zum Default-Konstruktor kann der Compiler auch Defaults für die Big Three
(Copy-Konstruktor, Destruktor, Zuweisungsoperator) generieren. Das funktioniert
nur, so lange Sie nicht selbst einen Copy-Konstruktor, Destruktor oder Zuweisungsoperator
definiert haben.</p>
<p>Diese Defaults passen normalerweise, wenn die Data-Member vom Typ <code>int</code>, <code>double</code>,
<code>vector&lt;int&gt;</code>, <code>string</code>, <code>vector&lt;string&gt;</code> o.ä. sind.</p>
<p>Problematisch wird es, wenn Pointer dabei sind: Dann werden flache Kopien erzeugt bzw.
Speicher auf dem Heap nicht oder mehrfach freigegeben! Sobald Sie für die Attribute
Pointer verwenden, sollten Sie eigene Konstruktoren, Copy-Konstruktoren, Destruktoren
und Zuweisungsoperatoren definieren!</p>
<p>Hier ein Beispiel für die Wirkung:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> initValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        value <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(initValue);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setValue</span>(<span style="color:#66d9ef">int</span> a) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>value <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// oberer Teil der Abbildung
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Dummy a(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    Dummy b <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>    Dummy c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unterer Teil der Abbildung
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    c<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>    a.setValue(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><a href="#R-image-0281c93aeaf5a39cb9abd31b2a48fd5e" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp3-big3/bigthreeDefaults.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0281c93aeaf5a39cb9abd31b2a48fd5e"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp3-big3/bigthreeDefaults.png?width=auto&height=auto"></a></p>
<p>Analyse:</p>
<ol>
<li>Es sind Pointer im Spiel. Es wurde ein eigener Konstruktor definiert, aber kein
Copy-Konstruktor, d.h. diesen &quot;spendiert&quot; der Compiler.</li>
<li>Beim Anlegen von <code>a</code> wird auf dem Heap Speicher für einen <code>int</code> reserviert und
dort der Wert <code>2</code> hineingeschrieben.</li>
<li>Beim Anlegen von <code>b</code> wird der Default-Copy-Konstruktor verwendet, der einfach
elementweise kopiert. Damit zeigt der Pointer <code>value</code> in <code>b</code> auf den selben
Speicher wie der Pointer <code>value</code> in <code>a</code>.</li>
<li>Der Ausdruck <code>c=b</code> ist eine Zuweisung (warum?). Auch hier wird der vom Compiler
bereitgestellte Default genutzt (elementweise Zuweisung). Damit zeigt nun auch
der Pointer <code>value</code> in <code>c</code> auf den selben Speicher wie die <code>value</code>-Pointer in
<code>a</code> und <code>b</code>.</li>
</ol>
<h3 id="hinweis-abarbeitungsreihenfolge">Hinweis Abarbeitungsreihenfolge</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">a</span>(<span style="color:#ae81ff">0</span>); Dummy <span style="color:#a6e22e">b</span>(<span style="color:#ae81ff">1</span>); Dummy <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">2</span>); Dummy <span style="color:#a6e22e">d</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> b <span style="color:#f92672">=</span> c <span style="color:#f92672">=</span> d; <span style="color:#75715e">// entspricht: a.operator=(b.operator=(c.operator=(d)));
</span></span></span></code></pre></div>
<h2 id="delete-this">delete this?</h2>
<p>Erinnerung:</p>
<ul>
<li><code>this</code> ist ein Pointer auf das eigene Objekt</li>
<li><code>delete</code> darf nur für Pointer auf Objekte, die mit <code>new</code> angelegt wurden,
aufgerufen werden =&gt; Freigabe von Objekten auf dem Heap!</li>
<li><code>delete</code> ruft den Destruktor eines Objekts auf ...</li>
</ul>
<p>Frage: Ist das folgende Konstrukt sinnvoll? Ist es überhaupt erlaubt? Was
passiert dabei?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Foo() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Analyse: Wir haben hier gleich zwei Probleme:</p>
<ol>
<li>
<p><code>delete</code> ruft den Destruktor des verwiesenen Objekts auf. Da <code>this</code> ein
Pointer auf das eigene Objekt ist, ruft <code>delete this;</code> den eigenen
Destruktor auf, der dann wiederum <code>delete this;</code> aufruft und so weiter.
=&gt; Endlosschleife!</p>
</li>
<li>
<p>Außerdem wissen wir im Destruktor bzw. im Objekt gar nicht, ob das Objekt
wirklich mit <code>new</code> auf dem Heap angelegt wurde! D.h. wenn wir nicht in
die Endlosschleife eintreten würden, würde das Programm abstürzen.</p>
</li>
</ol>
<p>Der Destruktor wird aufgerufen, wenn ein Objekt zerstört wird, d.h. wenn ein
Objekt seine Lebensdauer beendet (Verlassen des Scopes, in dem das Objekt
definiert wurde) bzw. wenn explizit ein <code>delete</code> auf das Objekt aufgerufen
wird (d.h. <code>delete</code> auf einen Pointer auf das Objekt, wobei dieses mit <code>new</code>
angelegt wurde).</p>
<p>Im Destruktor sollten <strong>durch das Objekt verwaltete Resourcen freigegeben</strong>
werden, d.h. sämtliche im Objekt mit <code>new</code> oder <code>malloc</code> allozierten Resourcen
auf dem Heap müssen freigegeben werden. Außerdem sollten ggf. offene Verbindungen
(offene Dateien, Datenbankverbindungen, Kommunikation, ...) geschlossen werden,
wenn sie durch das Objekt geöffnet wurden bzw. in der Verantwortung des Objekts
stehen. Einfache Datentypen oder Objekte, die nicht per Referenz oder Pointer
im Objekt verwaltet werden, werden automatisch freigegeben (denken Sie an das
Speichermodell - diese Daten &quot;stehen&quot; direkt im Speicherbereich des Objekts).</p>
<p>Der Speicherbereich für das Objekt selbst wird nach Beendigung des Destruktors
automatisch freigegeben (auf dem Stack wegen des Verlassen des Scopes (=&gt;
automatische Variable), auf dem Heap durch das vorherige Aufrufen von <code>delete</code>
auf den Pointer auf das Objekt im Heap), d.h. Sie brauchen im Destruktor <strong>kein</strong>
<code>delete</code> auf &quot;sich selbst&quot; (das ist wie oben demonstriert sogar schädlich)!</p>
<div class="box notices cstyle caution">
  <div class="box-label">
    <i class="fa-fw fas fa-hand"></i> Warnung
  </div>
  <div class="box-content">
<p>Auch wenn es zunächst irgendwie sinnvoll aussieht - rufen Sie <strong>niemals nie</strong> <code>delete this</code> im Destruktor auf!</p>
  </div>
</div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/deletethis.cpp" target="_blank"><span class="title">Konsole: deletethis.cpp</span></a></span></div>
<h2 id="c11-default-und-delete">C++11: <em>default</em> und <em>delete</em></h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Dummy() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">int</span> a) { value <span style="color:#f92672">=</span> a; }
</span></span><span style="display:flex;"><span>    Dummy(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>a) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>    Dummy <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Dummy <span style="color:#f92672">&amp;</span>d);
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<ul>
<li>C++ erzeugt etliche triviale Methoden/Operatoren, sofern man diese nicht
selbst definiert:
<ul>
<li>Methoden:
<ul>
<li>Standardkonstruktor</li>
<li>Copy-Konstruktor</li>
<li>Zuweisungsoperator</li>
<li>Destruktor</li>
</ul>
</li>
<li>Operatoren:
<ul>
<li>Operator <code>new</code></li>
<li>Operator <code>delete</code></li>
<li>Adresse von</li>
<li>Indirektion</li>
<li>Elementzugriff</li>
<li>Elementindirektion</li>
</ul>
</li>
</ul>
</li>
<li>Vor C++11: Default-Methode/-Operator verbieten: Sichtbarkeit auf <code>private</code>
setzen (Definition nicht nötig)</li>
<li>Ab C++11: Schlüsselwort <code>delete</code>: Entfernt Default-Methode/-Operator</li>
<li>C++11: Default-Methode/-Operator zusätzlich zu selbst implementierten:
Schlüsselwort <code>default</code></li>
</ul>
<h2 id="statische-methoden-und-attribute">Statische Methoden und Attribute</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Studi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getCount</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> Studi<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> Studi<span style="color:#f92672">::</span>getCount() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Studi<span style="color:#f92672">::</span>count;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Deklaration als <code>static</code> <strong>nicht</strong> in Implementierung wiederholen</li>
<li>Statische Attribute: Initialisierung <strong>immer</strong> außerhalb der Klasse!</li>
</ul>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/Studi.cpp" target="_blank"><span class="title">Konsole: Studi.cpp (static)</span></a></span></div>
<h2 id="konstante-methoden-und-kontexte">Konstante Methoden und Kontexte</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Studi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getCredits</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getCredits</span>();
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> Studi<span style="color:#f92672">::</span>getCredits() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> credits;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> Studi<span style="color:#f92672">::</span>getCredits() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> credits;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Das <code>const</code> gehört zur Signatur der Methode!</p>
<p>So wie im Beispiel gezeigt, gibt es jetzt zwei Methoden <code>getCredits()</code> - eine davon
ist konstant. Konstante Methoden dürfen auf konstanten Objekten/Referenzen aufgerufen
werden.</p>
<p>Was passiert, wenn das <code>const</code> auf der linken Seite steht? Dann bezieht es sich
auf den Rückgabewert:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> foo <span style="color:#a6e22e">wuppie</span>(foo<span style="color:#f92672">&amp;</span>, foo<span style="color:#f92672">&amp;</span>);</span></span></code></pre></div>
<p>Hier darf der Rückgabewert nicht als L-Wert benutzt werden: <code>wuppie(a,b) = c;</code> ist verboten.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/Studi.cpp" target="_blank"><span class="title">Konsole: Studi.cpp (const)</span></a></span></div>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Klassen: Destruktoren, Copy-Konstruktor, Zuweisungsoperator</li>
<li>Vorsicht mit Default-*struktoren/-operatoren</li>
<li>Statische Methoden und Attribute:
<ul>
<li>Deklaration als <code>static</code> <strong>nicht</strong> in Implementierung wiederholen</li>
<li>Statische Attribute: Initialisierung außerhalb der Klasse!</li>
</ul>
</li>
<li>Konstante Methoden und Kontexte
<ul>
<li><code>const</code> gehört zur Signatur der Methode!</li>
<li>Konstante Methoden dürfen auf konstanten Objekten/Referenzen aufgerufen werden</li>
</ul>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Konstruktor, Copy-Konstruktor, Zuweisungsoperator?</strong></p>
<ul>
<li>
<p>Erklären Sie die folgenden Anweisungen, worin liegt der Unterschied?</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy a;
</span></span><span style="display:flex;"><span>Dummy b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">4</span>);</span></span></code></pre></div>
</li>
<li>
<p>Erklären Sie die folgenden Anweisungen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy a;
</span></span><span style="display:flex;"><span>Dummy b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>Dummy d <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">e</span>(b);
</span></span><span style="display:flex;"><span>Dummy f;
</span></span><span style="display:flex;"><span>f <span style="color:#f92672">=</span> b;</span></span></code></pre></div>
</li>
</ul>
<p><strong>Destruktor</strong></p>
<ul>
<li>Erklären Sie die Wirkungsweise eines Destruktors.</li>
<li>Wann wird ein Destruktor aufgerufen?</li>
<li>Warum ist <code>delete this</code> keine gute Idee (nicht nur im Destruktor)?!</li>
<li>Was sollten Sie im Destruktor aufräumen, was nicht?</li>
</ul>
<p><strong>Die &quot;Großen Drei&quot;</strong></p>
<ol>
<li>
<p>Beschreiben Sie den Unterschied der folgenden beiden Codeblöcke (<code>A</code> sei
eine beliebige Klasse):</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A a, b <span style="color:#f92672">=</span> a;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A a, b; b <span style="color:#f92672">=</span> a;</span></span></code></pre></div>
</li>
<li>
<p>Erläutern Sie an einem <strong>Beispiel</strong> die Regel der &quot;Big Three&quot;:</p>
<blockquote>
<p>Ist ein Copy-Konstruktor, ein Destruktor oder ein eigener
Zuweisungsoperator notwendig, muss man in der Regel die jeweils anderen
beiden ebenfalls bereit stellen.</p>
</blockquote>
</li>
<li>
<p>Beim Zuweisungsoperator werden Selbstzuweisungen, d.h. ein Objekt soll an
sich selbst zugewiesen werden, üblicherweise durch eine entsprechende
Prüfung vermieden.</p>
<p>Begründen Sie diese Praxis, indem Sie ein <strong>Beispiel konstruieren</strong>, bei
dem es zu Datenverlust kommt, wenn die Selbstzuweisung nicht unterbunden
wird.</p>
<div class="expand">
  <input type="checkbox" id="R-expand-7045bd7a16c2295422cfa3cb2c5437a4" aria-controls="R-expandcontent-7045bd7a16c2295422cfa3cb2c5437a4">
  <label class="expand-label" for="R-expand-7045bd7a16c2295422cfa3cb2c5437a4">
    <i class="expander-icon fa-fw fas fa-chevron-down"></i>
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> Show Me
  </label>
  <div id="R-expandcontent-7045bd7a16c2295422cfa3cb2c5437a4" class="expand-content">
<pre><code>Wenn vor der Wertzuweisung der alte Inhalt freigegeben werden muss, führt
Selbstzuweisung zum Fehler.

Können Sie ein konkretes Beispiel angeben?
</code></pre>
  </div>
</div>
</li>
</ol>
<p><strong>Quiz: Was passiert bei den folgenden Aufrufen?</strong></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> Foo <span style="color:#f92672">&amp;</span>bar(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>a) { <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>]; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Foo f;  vector<span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span> a <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>, <span style="color:#e6db74">&#34;:)&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Foo s1 <span style="color:#f92672">=</span> f.bar(a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> Foo <span style="color:#f92672">&amp;</span>s2 <span style="color:#f92672">=</span> f.bar(a);
</span></span><span style="display:flex;"><span>    Foo <span style="color:#f92672">&amp;</span>s3 <span style="color:#f92672">=</span> f.bar(a);
</span></span><span style="display:flex;"><span>    Foo s4;
</span></span><span style="display:flex;"><span>    s4 <span style="color:#f92672">=</span> f.bar(a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Operatoren</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>In C++ können existierende Operatoren überladen werden, etwa für die Nutzung mit eigenen Klassen. Dabei
kann die Überladung innerhalb einer Klassendefinition passieren (analog zur Implementierung einer Methode)
oder außerhalb der Klasse (analog zur Definition einer überladenen Funktion).</p>
<p>Beim Überladen in einer Klasse hat der Operator nur einen Parameter (beim Aufruf das Objekt auf der rechten
Seite) und man kann auf die Attribute der Klasse direkt zugreifen. Bei der Überladung außerhalb der Klasse
hat der Operator zwei Parameter und darf nicht auf die Attribute der Klasse zugreifen.</p>
<p>Man kann Funktionen, Methoden/Operatoren und Klassen als <code>friend</code> einer Klasse deklarieren. Damit bricht
man die Kapselung auf und erlaubt den Freunden den direkten Zugriff auf die internen Attribute einer Klasse.</p>
<p>Um bei der Implementierung von Post- und Präfix-Operatoren die Variante für den Compiler unterscheidbar zu
machen, hat die Signatur der Postfix-Variante einen Dummy-Parameter vom Typ <code>int</code>. Dieser wird beim Aufruf
aber nicht genutzt.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/lCe0mmO613M' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL C++: Operatoren</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Implizite Typkonvertierungen bei Operatoren</li> <li>(K3) Überladen von Operatoren (innerhalb bzw. außerhalb einer Klasse)</li> <li>(K3) Anwendung der Deklaration als <code>friend</code></li> <li>(K3) Implementierung von Post- und Präfix-Operatoren</li></ul>
  </div>
</div>




    <h2 id="überladen-von-operatoren-in-klassen">Überladen von Operatoren <em>in</em> Klassen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>MyString a, b(<span style="color:#e6db74">&#34;hallo&#34;</span>);
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> b;      <span style="color:#75715e">// ???
</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>a.<span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(b);</span></span></code></pre></div>
<p>Aufruf <code>a=b</code> ist äquivalent zu <code>a.operator=(b)</code></p>
<p>Überladen ähnlich wie bei Methoden:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyString</span> {
</span></span><span style="display:flex;"><span>    MyString <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> MyString <span style="color:#f92672">&amp;</span>s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>s) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// mach was :-)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Analog weitere Operatoren, etwa <code>operator==</code>, <code>operator+</code>, ... überladen</p>
<h2 id="überladen-von-operatoren-außerhalb-von-klassen">Überladen von Operatoren <em>außerhalb</em> von Klassen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>MyString <span style="color:#a6e22e">a</span>(<span style="color:#e6db74">&#34;hallo&#34;</span>);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyString</span> {
</span></span><span style="display:flex;"><span>    ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>o) { <span style="color:#66d9ef">return</span> o <span style="color:#f92672">&lt;&lt;</span> str; }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><span class='alert'><strong>So funktioniert das leider nicht!</strong></span></p>
<ul>
<li>Erinnerung: <code>cout &lt;&lt; a</code> entspricht <code>cout.operator&lt;&lt;(a)</code>
<ul>
<li>Operator kann nicht in <code>MyString</code> überladen werden!</li>
<li>Klasse <code>ostream</code> müsste erweitert werden
=&gt; Geht aber nicht, da System-weite Klasse!</li>
</ul>
</li>
</ul>
<p>=&gt; Lösung: Operator <span class='alert'><strong>außerhalb</strong></span> der Klasse überladen =&gt; 2 Parameter</p>
<h2 id="überladen-von-operatoren-außerhalb-von-klassen-cnt">Überladen von Operatoren <em>außerhalb</em> von Klassen (cnt.)</h2>
<p>Operator außerhalb der Klasse überladen =&gt; 2 Parameter</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>out, <span style="color:#66d9ef">const</span> MyString <span style="color:#f92672">&amp;</span>s) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> out <span style="color:#f92672">&lt;&lt;</span> s.str;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li><span class='alert'>Nachteil</span>: Benötigt Zugriff auf Klassen-Interna
<ul>
<li>
<p>entweder umständlich über Getter-Funktionen</p>
</li>
<li>
<p>oder als <code>friend</code> der Klasse <code>MyString</code> deklarieren</p>
<p>Alternativ Zugriffsmethoden (aka <em>Getter</em>) nutzen wie <code>toString()</code> ...</p>
</li>
</ul>
</li>
</ul>
<p><strong>Anmerkung</strong>: Rückgabe der Referenz auf den Stream erlaubt die typische
Verkettung: <code>cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;</code></p>
<h2 id="meine-freunde-dürfen-in-mein-wohnzimmer">Meine Freunde dürfen in mein Wohnzimmer</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestDummy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ganzTolleMethode</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dummy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestDummy</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">int</span> TestDummy<span style="color:#f92672">::</span>ganzTolleMethode();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>();
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="fast-alle-operatoren-lassen-sich-überladen">(Fast) alle Operatoren lassen sich überladen</h2>
<ul>
<li>
<p>Alle normalen arithmetischen Operatoren</p>
</li>
<li>
<p>Zuweisung, Vergleich, Ein-/Ausgabe</p>
</li>
<li>
<p>Index-Operator <code>[]</code>, Pointer-Dereferenzierung <code>*</code> und
<code>-&gt;</code>, sowie <code>()</code>, <code>new</code> und <code>delete</code> (auch in <code>[]</code>-Form)</p>
</li>
<li>
<p><strong>Ausnahmen</strong>:</p>
<ol>
<li><span class='alert'><strong>.</strong></span></li>
<li><span class='alert'><strong>::</strong></span></li>
<li><span class='alert'><strong>?:</strong></span></li>
<li><span class='alert'><strong>sizeof</strong></span></li>
</ol>
</li>
<li>
<p>Anmerkungen:</p>
<ul>
<li>Beim Überladen muss die Arität erhalten bleiben</li>
<li>Nur <em>existierende</em> Operatoren lassen sich überladen
=&gt; Es lassen sich keine neuen Operatoren erschaffen</li>
</ul>
</li>
</ul>
<p>Vgl. Tabelle 9.1 (S. 318) im <a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp4-operators.html#id_Breymann2011">[Breymann2011]</a></p>
<h2 id="implizite-typkonvertierungen-bei-aufruf">Implizite Typkonvertierungen bei Aufruf</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>MyString s;
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;123&#34;</span>;     <span style="color:#75715e">// ???
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;123&#34;</span> <span style="color:#f92672">!=</span> s;     <span style="color:#75715e">// ???
</span></span></span></code></pre></div>
<ul>
<li>
<p>Operatoren <strong>in</strong> Klasse überladen: <span class='alert'>Typ der linken Seite muss</span> <span class='alert'><strong>exakt</strong></span> <span class='alert'>passen</span></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyString</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyString(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">!=</span>(<span style="color:#66d9ef">const</span> MyString<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyString s;
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;123&#34;</span>;    <span style="color:#75715e">// impliziter Aufruf des Konstruktors, danach MyString::operator!=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;123&#34;</span> <span style="color:#f92672">!=</span> s;    <span style="color:#75715e">// KEIN operator!=(char*, MyString&amp;) vorhanden!
</span></span></span></code></pre></div>
<p>Das ist letztlich wie bei einem Methodenaufruf: Um die richtige Methode aufzurufen, muss
der Typ (die Klasse) des Objekts bekannt sein.</p>
</li>
<li>
<p>Operatoren <strong>außerhalb</strong> überladen: Konvertierung auf <em>beiden</em> Seiten möglich</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyString</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyString(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">!=</span>(<span style="color:#66d9ef">const</span> MyString<span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> MyString<span style="color:#f92672">&amp;</span>);</span></span></code></pre></div>
</li>
</ul>
<p><span class='alert'><strong>NIEMALS</strong></span> beide Formen <span class='alert'>gleichzeitig</span> für einen Operator implementieren!</p>
<h2 id="anmerkung-zu--und--hahahugoshortcode27s0hbhb--operatoren-präfix-und-postfix">Anmerkung zu &quot;++&quot; und &quot;-<span class="math align-center">$\,$</span>-&quot; Operatoren: Präfix und Postfix</h2>
<ul>
<li>
<p>Präfix: <code>o1 = ++o2;</code></p>
<ul>
<li>Objekt soll <strong>vor Auswertung</strong> inkrementiert werden</li>
<li>Signatur: <code>Typ &amp;operator++()</code></li>
</ul>
</li>
<li>
<p>Postfix: <code>o1 = o2++;</code></p>
<ul>
<li>Objekt soll erst <strong>nach Auswertung</strong> inkrementiert werden</li>
<li>Signatur: <code>Typ operator++(int)</code>
(=&gt; <code>int</code> dient nur zur Unterscheidung der Präfix-Variante, wird <strong>nie</strong> benutzt)</li>
</ul>
</li>
</ul>
<h2 id="weitere-anmerkungen">Weitere Anmerkungen</h2>
<ul>
<li>
<p>Operatoren werden <span class='alert'><strong>nicht</strong></span> vom System zusammengesetzt</p>
<ul>
<li><code>operator+</code> und <code>operator+=</code> sind zwei <span class='alert'>verschiedene</span> Operatoren!</li>
<li>Implementierung ist prinzipiell <span class='alert'>unabhängig</span>!
=&gt; Erwartung: <code>operator+=</code> <span class="math align-center">$\;==\;$</span> (<code>operator+</code> <span class="math align-center">$\;+\;$</span> <code>operator=</code>)</li>
</ul>
</li>
<li>
<p>Operatoren lassen sich in C++ verketten:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Dummy <span style="color:#a6e22e">a</span>(<span style="color:#ae81ff">0</span>); Dummy <span style="color:#a6e22e">b</span>(<span style="color:#ae81ff">1</span>); Dummy <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> b <span style="color:#f92672">=</span> c;  <span style="color:#75715e">// a.operator=(b.operator=(c));
</span></span></span></code></pre></div>
</li>
<li>
<p>Übertreiben Sie nicht!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Firma f;
</span></span><span style="display:flex;"><span>Person p;
</span></span><span style="display:flex;"><span>f <span style="color:#f92672">+=</span> p;  <span style="color:#75715e">// ??!
</span></span></span></code></pre></div>
<p>Nutzen Sie im Zweifel lieber Methoden mit aussagekräftigen Namen!</p>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Überladen von Operatoren (innerhalb und außerhalb einer Klasse)
<ul>
<li>Innerhalb: 1 Parameter (Objekt auf der rechten Seite)</li>
<li>Außerhalb: 2 Parameter</li>
</ul>
</li>
<li>Zugriff auf Attribute: <code>friend</code> einer Klasse</li>
<li>Implementierung von Post- und Präfix-Operatoren</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Operator &quot;++&quot;</strong></p>
<p>Betrachten Sie die folgende Klasse:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Studi</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Studi(<span style="color:#66d9ef">int</span> credits);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Studi();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>credits;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Implementieren Sie den <code>operator++</code> sowohl in der Präfix- als auch in der Postfix-Variante.</p>
<p><strong>C'toren und Operatoren: Was muss noch <em>deklariert</em> werden?</strong></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Studi</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Studi(<span style="color:#66d9ef">int</span> credits);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>credits;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Studi a(<span style="color:#ae81ff">1</span>), b, <span style="color:#f92672">*</span>c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Studi(<span style="color:#ae81ff">99</span>);
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>c<span style="color:#f92672">+</span>a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b: &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39; credits&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><strong>Schreiben Sie Code, damit folgender Code kompiliert:</strong></p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>test wuppie;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> fluppie <span style="color:#f92672">=</span> wuppie(<span style="color:#ae81ff">3</span>);</span></span></code></pre></div>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Vererbung und Polymorphie</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Vererbung analog zu Java passiert in C++ über die &quot;<code>public</code>-Vererbung&quot;: <code>Subklasse : public Superklasse</code>.
Dabei gibt es in C++ <strong>keine</strong> gemeinsame Oberklasse wie <code>Object</code> und entsprechend kein <code>super</code>. (Es
kann auch private Vererbung geben.)</p>
<p>Operatoren und *struktoren werden in den vom Compiler erzeugten Defaults richtig verkettet. Bei der
eigenen Implementierung von Operatoren und Konstruktoren muss zunächst der Operator/Konstruktor der
Basisklasse aufgerufen werden (Basisklassen-Konstruktoren dabei in der Initialisierungsliste!), danach
erfolgt die Implementierung für die eigenen Attribute der abgeleiteten Klasse. Der Zugriff auf die
Elemente der Elternklasse erfolgt dabei über den Namen der Elternklasse und den Scope-Operator (nicht
mit <code>super</code>!). Destruktoren von abgeleiteten Klassen müssen sich dagegen nur um die zusätzlichen
Attribute der abgeleiteten Klasse kümmern, der Basisklassendestruktor wird automatisch verkettet bzw.
aufgerufen.</p>
<p>Abstrakte Klassen in C++ haben mindestens eine abstrakte Methode. Eine Methode ist abstrakt, wenn sie
als &quot;<code>virtual</code>&quot; deklariert ist <strong>und</strong> der Deklaration ein &quot;<code>=0</code>&quot; folgt.</p>
<p>In C++ hat man aus Effizienzgründen per Default statische Polymorphie. Bei der Zuweisung eines Objekts
einer abgeleiteten Klasse (rechte Seite) an ein Objekt vom Typ der Oberklasse (linke Seite) erfolgt
dabei &quot;Slicing&quot;, d.h. alle zusätzlichen Eigenschaften der abgeleiteten Klasse gehen dabei verloren.
Dynamische Polymorphie kann man in C++ nutzen, indem man (a) die gewünschten Methoden in der Basisklasse
als <code>virtual</code> deklariert und (b) für den Zugriff auf die Objekte der abgeleiteten Klasse Pointer oder
Referenzen vom Basisklassen-Typ benutzt.</p>
<p>In C++ ist Mehrfachvererbung möglich, d.h. eine Klasse kann von mehreren anderen Klassen erben. Damit
erbt sie auch das Objekt-Layout aller Elternklassen.</p>
<p>Bei rautenförmigen Vererbungsbeziehung führt dies zu Problemen, da Attribute und Methoden der gemeinsamen
Basisklasse mehrfach vorhanden (über jeden Zweig der Raute).</p>
<p>Zur Umgehung des Problems kann man die gemeinsam genutzten Basisklassen &quot;<code>virtual</code>&quot; deklarieren. Dadurch
sind gemeinsam genutzte Attribute und Methoden nur noch einfach vorhanden. Da die Klassen &quot;in der Raute&quot;
ihrerseits den Konstruktor der Basisklasse aufrufen (könnten) und es dadurch zu Konflikten beim Setzen
der Attribute der Basisklasse kommen kann, gelten bei virtueller Ableitung Sonderregeln: Für die virtuelle
Basisklasse wird die Weiterleitung der Werte aufgehoben (es muss also ein parameterloser Konstruktor existieren,
der durch die direkten Unterklassen aufgerufen wird) und die Klasse am &quot;unteren Ende der Raute&quot; kann direkt
den Konstruktor der virtuellen Basisklasse am &quot;oberen Ende der Raute&quot; aufrufen.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/yiIXDWRpKU4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL C++: Vererbung und Polymorphie</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Unterschied zwischen <code>public</code>- und <code>private</code>-Vererbung</li> <li>(K2) Unterschied Überladen und Überschreiben</li> <li>(K2) Slicing in C++</li> <li>(K2) Probleme bei Mehrfachvererbung und Einsatz virtueller Basisklassen</li> <li>(K3) <code>public</code>-Vererbung in C++</li> <li>(K3) Verkettung von Operatoren und *struktoren</li> <li>(K3) Statische und dynamische Polymorphie in C++</li> <li>(K3) Abstrakte Klassen in C++</li> <li>(K2) Probleme bei Mehrfachvererbung und Einsatz virtueller Basisklassen</li> <li>(K3) Praktischer Umgang mit Mehrfachvererbung</li></ul>
  </div>
</div>




    <h2 id="vererbung-is-a-beziehung-zw-klassen">Vererbung: &quot;IS-A&quot;-Beziehung zw. Klassen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Person { ... }</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Student(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#66d9ef">double</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">:</span> Person(name), credits(c) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Student(<span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span>s)
</span></span><span style="display:flex;"><span><span style="color:#f92672">:</span> Person(s), credits(s.credits) { }</span></span></code></pre></div>
<p>Analog zu Java:</p>
<ul>
<li><code>Student</code>: abgeleitete Klasse</li>
<li><code>Person</code>: Basisklasse</li>
<li><code>: public</code>: Vererbungsbeziehung (analog zu <code>extends</code> in Java)</li>
<li><code>public</code>-Vererbung: Verhalten wie in Java</li>
<li>Hinweis: Es gibt weitere Spielarten (<code>protected</code>, <code>private</code>), vgl. Semesterliteratur</li>
<li>Ab C++11:
<ul>
<li>Schlüsselwort <code>override</code>:
Die Methode muss eine virtuelle Methode der Klassenhierarchie überschreiben.</li>
<li>Schlüsselwort <code>final</code>:
Die virtuelle Methode darf nicht in abgeleiteten Klassen überschrieben werden.</li>
</ul>
</li>
</ul>
<h3 id="vererbung-und-konstruktoren">Vererbung und Konstruktoren</h3>
<ul>
<li>Defaultkonstruktoren werden automatisch richtig verkettet
<ul>
<li>zuerst Aufruf des Basisklassen-Konstruktors</li>
<li>anschließend Behandlung der zusätzlichen Attribute</li>
</ul>
</li>
<li>Eigene Konstruktoren verketten:
<ul>
<li><span class='alert'>Zuerst</span> Basisklassen-Konstruktor aufrufen (in
Initialisierungsliste!)
=&gt; Konkreten Konstruktor nehmen, nicht <code>super</code> wie in Java</li>
</ul>
</li>
</ul>
<h3 id="vererbung-und-destruktoren">Vererbung und Destruktoren</h3>
<ul>
<li>Defaultdestruktoren werden automatisch richtig verkettet
<ul>
<li>zuerst werden die Destruktoren der zusätzlichen Attribute aufgerufen</li>
<li>dann der Destruktor der Basisklasse</li>
</ul>
</li>
<li>Eigene Destruktoren werden automatisch verkettet</li>
<li>Destruktor abgeleiteter Klasse muss sich nur um zusätzliche Attribute kümmern</li>
</ul>
<h3 id="vererbung-und-operatoren">Vererbung und Operatoren</h3>
<ul>
<li>Defaultoperatoren werden automatisch richtig verkettet
<ul>
<li>zuerst Aufruf des Basisklassen-Operators</li>
<li>anschließend Behandlung der zusätzlichen Attribute</li>
</ul>
</li>
<li>Eigene Operatoren am Beispiel Zuweisungsoperator:
<ul>
<li>
<p>Zuerst den Zuweisungsoperator der Basisklasse aufrufen</p>
</li>
<li>
<p>Zugriff über Superklassennamen und Scope-Operator (nicht mit <code>super</code>!)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span>s) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>s) {
</span></span><span style="display:flex;"><span>        Person<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(s);
</span></span><span style="display:flex;"><span>        credits <span style="color:#f92672">=</span> s.credits;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
</li>
</ul>
<h3 id="vererbung-von-freundschaften">Vererbung von Freundschaften</h3>
<ul>
<li>Freundschaften werden nicht vererbt!</li>
<li><code>friends</code> der Basisklasse haben keinen Zugriff auf zusätzliche
private Attribute/Methoden der Unterklassen</li>
<li>Aber: weiterhin Zugriff auf die geerbten privaten Elemente!</li>
</ul>
<h2 id="abstrakte-klassen">Abstrakte Klassen</h2>
<ul>
<li>Eine <strong>Klasse</strong> ist <span class='alert'>abstrakt</span>, wenn sie mindestens eine abstrakte Methode hat</li>
<li>Eine <strong>Methode</strong> ist in C++ <span class='alert'>abstrakt</span>, wenn sie
<ol>
<li>als <span class='alert'>virtuell</span> deklariert ist, <strong>und</strong></li>
<li>der Deklaration ein &quot;<code>=0</code>&quot; folgt</li>
</ol>
</li>
</ul>
<p><span class='alert'>Abstrakte Methoden</span> können <span class='alert'>Implementierung</span> haben! =&gt; Implementierung <span class='alert'>außerhalb</span> der Klassendeklaration</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> string toString() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string Person<span style="color:#f92672">::</span>toString() <span style="color:#66d9ef">const</span> { ... }  <span style="color:#75715e">// Implementierung :-)
</span></span></span></code></pre></div>
<h2 id="polymorphie-was-passiert-im-folgenden-beispiel">Polymorphie: Was passiert im folgenden Beispiel?</h2>
<p>IS-A Beziehung: Objekte können als Objekte ihrer Oberklasse behandelt werden</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> { ... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Person { ... }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Student <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;Heinz&#34;</span>, <span style="color:#e6db74">&#34;heizer&#34;</span>);
</span></span><span style="display:flex;"><span>Person <span style="color:#f92672">&amp;</span>p <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> s.toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> p.toString() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/polyStat.cpp" target="_blank"><span class="title">Konsole: polyStat.cpp</span></a></span></div>
<p>Antwort: Es wird die falsche Methode aufgerufen!</p>
<ul>
<li><code>s.toString()</code> =&gt; <code>Student::toString()</code> =&gt; wie erwartet</li>
<li><code>p.toString()</code> =&gt; <code>Person::toString()</code> =&gt; <span class='alert'><strong>unerwartet</strong></span>!</li>
</ul>
<h2 id="polymorphie-statisch-und-dynamisch">Polymorphie: statisch und dynamisch</h2>
<ul>
<li>
<p>C++ entscheidet zur <span class='alert'><strong>Kompilierzeit</strong></span>, welche Methode aufgerufen wird</p>
<ul>
<li><code>p</code> ist vom Typ <code>Person</code> =&gt; <code>p.toString()</code>
=&gt; <code>Person::toString()</code></li>
<li>Dieses Verhalten wird <strong>statisches Binden</strong> genannt.</li>
</ul>
</li>
<li>
<p>Von Java her bekannt: <strong>dynamisches Binden</strong></p>
<ul>
<li>Typ eines Objektes wird zur <strong>Laufzeit</strong> ausgewertet</li>
</ul>
</li>
</ul>
<h2 id="dynamisches-binden-geht-auch-in-c-">Dynamisches Binden geht auch in C++ ...</h2>
<p>Für dynamische Polymorphie müssen in C++ drei Bedingungen erfüllt sein:</p>
<ol>
<li>
<p>Methoden in <strong>Basisklasse</strong> als <strong>virtuelle Funktion</strong> deklarieren
=&gt; Schlüsselwort <code>virtual</code></p>
</li>
<li>
<p>Virtuelle Methoden in Subklasse normal überschreiben (gleiche Signatur)</p>
<p>Zusätzlich muss der Rückgabetyp exakt übereinstimmen
(Ausnahme: Rückgabe Pointer/Referenz auf <em>abgeleitete</em> Klasse)</p>
</li>
<li>
<p>Objekte mittels Basisklassen-Referenzen bzw. -Pointer zugreifen (siehe nächste Folie)</p>
</li>
</ol>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> string <span style="color:#a6e22e">toString</span>() <span style="color:#66d9ef">const</span> { ... }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/polyDyn.cpp" target="_blank"><span class="title">Konsole: polyDyn.cpp</span></a></span></div>
<h2 id="vorsicht-slicing">Vorsicht Slicing</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Student <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;Heinz&#34;</span>, <span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>Person <span style="color:#a6e22e">p</span>(<span style="color:#e6db74">&#34;Holger&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt s (Student): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt p (Person):  &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.toString() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/polySlicing.cpp" target="_blank"><span class="title">Konsole polySlicing.cpp</span></a></span></div>
<p>=&gt; <code>p</code> ist vom Typ <code>Person</code></p>
<ul>
<li>Zuweisung von Objekten vom Typ <code>Student</code> ist erlaubt (Polymorphie)</li>
<li><code>p</code> hat aber nur Speicherplatz für genau eine <code>Person</code>
=&gt; &quot;Abschneiden&quot; aller Elemente, die nicht Bestandteil von
<code>Person</code> sind!</li>
<li>Slicing passiert immer beim <span class='alert'>Kopieren/Zuweisen</span> von Objekten</li>
</ul>
<p>=&gt; <strong>Dyn. Polymorphie</strong> in C++ immer über <span class='alert'><strong>Referenzen</strong></span>
(bzw. Pointer) <strong>und</strong> <span class='alert'><strong>virtuelle Methoden</strong></span></p>
<p>Wir hatten die Methode <code>toString</code> in der Basisklasse <code>Person</code> zwar als <code>virtual</code> deklariert,
und wir hatten diese Methode in der ableitenden Klasse <code>Studi</code> passend überschrieben.</p>
<p>Damit haben wir aber nur zwei der drei Bedingungen für dynamische Polymorphie in C++
erfüllt. Wenn wir Objekte vom Typ <code>Studi</code> über eine normale Variable vom Typ <code>Person</code>
handhaben, haben wir immer noch statische Polymorphie - uns stehen also nur die Methoden
aus und in <code>Person</code> zur Verfügung.</p>
<p>Zusätzlich haben wir durch die Zuweisung <code>p = s;</code> das Objekt <code>s</code> in den Speicherbereich
von <code>p</code> &quot;gequetscht&quot;. Dieses ist vom Typ <code>Person</code> und hat auch nur (Speicher-) Platz für
Elemente dieses Typs. Alles andere wird bei der Zuweisung &quot;abgeschnitten&quot;, d.h. <code>p</code> ist
immer noch ein Objekt vom Typ <code>Person</code>, der zusätzliche Rest aus <code>Studi</code> fehlt ...</p>
<p>Wir könnten das durch Pointer oder Referenzen heilen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Variante mit Basisklassen-Pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Student <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;Heinz&#34;</span>, <span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>Person <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt s (Student): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.toString()  <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt p (Person):  &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">-&gt;</span>toString() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<p><em>Anmerkung</em>: Der Operator <code>-&gt;</code> ist die zusammengefasste Dereferenzierung des Pointers und
der nachfolgende Zugriff auf Methoden oder Attribute. Man könnte also entsprechend auch
<code>(*p).toString()</code> statt <code>p-&gt;toString()</code> schreiben.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Variante mit Basisklassen-Referenz
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Student <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;Heinz&#34;</span>, <span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>Person <span style="color:#f92672">&amp;</span>p <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt s (Student): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Objekt p (Person):  &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.toString() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<p>Erst damit erfüllen wir die dritte Bedingung und haben echte dynamische Polymorphie in C++.</p>
<h2 id="anmerkungen-zu-polymorphie-in-c">Anmerkungen zu Polymorphie in C++</h2>
<ul>
<li><strong>Gestaltung der API</strong>:
<ul>
<li>Zum Überschreiben gedachte Methoden als virtuell deklarieren</li>
<li>Nicht virtuelle Methoden aus der Basisklasse nicht überschreiben</li>
</ul>
</li>
<li>Trennung von Deklaration und Implementierung:
<ul>
<li>Deklaration als virtuelle Funktion nur im Deklarationsteil</li>
<li>Keine Wiederholung im Implementierungsteil (analog zu Defaultwerten)</li>
</ul>
</li>
<li>&quot;Virtualität vererbt sich&quot;:
<ul>
<li>Virtuelle Funktionen sind virtuell in der Vererbungshierarchie hinab ab
der ersten Deklaration als virtuell</li>
</ul>
</li>
<li>Virtualität ist &quot;teuer&quot;: Es muss eine Tabelle aller virtuellen Funktionen aufgebaut werden und zur
Laufzeit geprüft werden, welche Funktion genommen werden soll</li>
</ul>
<h2 id="mehrfachvererbung-in-c">Mehrfachvererbung in C++</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HiWi</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student, <span style="color:#66d9ef">public</span> Angestellter {...};</span></span></code></pre></div>
<p><a href="#R-image-b62091cef91e6af28b70178129c08114" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-studi_new.png?width=50%25&height=auto" style=" height: auto; width: 50%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b62091cef91e6af28b70178129c08114"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-studi_new.png?width=50%25&height=auto"></a></p>
<div style="text-align: right;"><span class="badge cstyle default"><span class="badge-content">Hinweis Speicherlayout ...</span></span></div>
<h3 id="problem-1-gleichnamige-methoden-aus-basisklassen-geerbt">Problem 1: Gleichnamige Methoden aus Basisklassen geerbt</h3>
<p><a href="#R-image-84e63b2307127cf3f9ab48fb06959a69" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-namenskollision_new.png?width=50%25&height=auto" style=" height: auto; width: 50%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-84e63b2307127cf3f9ab48fb06959a69"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-namenskollision_new.png?width=50%25&height=auto"></a></p>
<p>Namenskollision bei Mehrfachvererbung auflösen:</p>
<ul>
<li>
<p>Scope-Operator <code>::</code> nutzen:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>HiWi <span style="color:#a6e22e">h</span>(<span style="color:#e6db74">&#34;Anne&#34;</span>, <span style="color:#ae81ff">23.0</span>, <span style="color:#ae81ff">40.0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Student<span style="color:#f92672">::</span>toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Angestellter<span style="color:#f92672">::</span>toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Student<span style="color:#f92672">::</span>getName() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Angestellter<span style="color:#f92672">::</span>getName() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
</li>
<li>
<p>Methode in abgeleiteter Klasse überschreiben</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>HiWi <span style="color:#a6e22e">h</span>(<span style="color:#e6db74">&#34;Anne&#34;</span>, <span style="color:#ae81ff">23.0</span>, <span style="color:#ae81ff">40.0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Student<span style="color:#f92672">::</span>toString() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> h.Angestellter<span style="color:#f92672">::</span>toString() <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
</li>
</ul>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/vererbungMultiMethoden.cpp" target="_blank"><span class="title">Konsole vererbungMultiMethoden.cpp</span></a></span></div>
<h3 id="problem-2-gemeinsam-geerbte-attribute-sind-mehrfach-vorhanden">Problem 2: Gemeinsam geerbte Attribute sind mehrfach vorhanden</h3>
<p><a href="#R-image-4567006ffc4ae2313b93dcd7226f8f38" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-attributkollision_new.png?width=50%25&height=auto" style=" height: auto; width: 50%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4567006ffc4ae2313b93dcd7226f8f38"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/99-languages/cpp5-inheritance/mehrfachvererbung-attributkollision_new.png?width=50%25&height=auto"></a></p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/vererbungMultiAttribute.cpp" target="_blank"><span class="title">Konsole vererbungMultiAttribute.cpp</span></a></span></div>
<h2 id="mehrfachvererbung-in-c-virtuelle-basisklassen">Mehrfachvererbung in C++: Virtuelle Basisklassen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Angestellter</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> Person {...};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> Person {...};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HiWi</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student, <span style="color:#66d9ef">public</span> Angestellter {...};</span></span></code></pre></div>
<ul>
<li><code>Person</code> ist jetzt eine <span class='alert'>virtuelle Basisklasse</span></li>
<li>Auswirkungen erst in Klasse <code>HiWi</code></li>
<li>Dadurch sind gemeinsam genutzte Anteile nur einfach vorhanden</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Student <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;Heinz&#34;</span>, <span style="color:#ae81ff">10.0</span>);           <span style="color:#75715e">// wie vorher: nur EIN name-Feld
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Angestellter <span style="color:#a6e22e">a</span>(<span style="color:#e6db74">&#34;Holger&#34;</span>, <span style="color:#ae81ff">80.5</span>);     <span style="color:#75715e">// wie vorher: nur EIN name-Feld
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>HiWi <span style="color:#a6e22e">h</span>(<span style="color:#e6db74">&#34;Anne&#34;</span>, <span style="color:#ae81ff">23.0</span>, <span style="color:#ae81ff">40.0</span>);         <span style="color:#75715e">// jetzt auch nur EIN name-Feld
</span></span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/vererbungMultiVirtual.cpp" target="_blank"><span class="title">Konsole vererbungMultiVirtual.cpp</span></a></span></div>
<h2 id="sonderregeln-bei-virtueller-ableitung">Sonderregeln bei virtueller Ableitung</h2>
<p>Virtuelle Ableitung: Potentiell Konflikte zwischen Konstruktoren!</p>
<ul>
<li>Gemeinsam geerbtes Attribut nur noch <span class='alert'>einmal</span> vorhanden</li>
<li>Konstruktoren werden <span class='alert'>nacheinander</span> aufgerufen, alle wollen das
gemeinsame Attribut initialisieren (durch Aufruf des Konstruktors der
jeweiligen Basisklasse)</li>
<li>Zuletzt aufgerufener Konstruktor würde &quot;gewinnen&quot;</li>
</ul>
<p>Deshalb gibt es bei virtueller Ableitung folgende Sonderregeln:</p>
<ol>
<li>
<p>Für virtuelle Basisklassen ist <strong>Mechanismus des Weiterreichens</strong> von
Initialisierungswerten <span class='alert'><strong>deaktiviert</strong></span></p>
</li>
<li>
<p>Konstruktor einer virtuellen Basisklasse kann in Initialisierungsliste von
indirekten Unterklassen aufgerufen werden</p>
<p>Sonst wird der Defaultkonstruktor der virtuellen Basisklasse genutzt!</p>
</li>
</ol>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/vererbungMultiVirtual.cpp" target="_blank"><span class="title">Konsole vererbungMultiVirtual.cpp (Basiskonstruktor)</span></a></span></div>
<h2 id="mehrfachvererbung-in-c-ist-ein-recht-kompliziertes-thema">Mehrfachvererbung in C++ ist ein recht kompliziertes Thema</h2>
<p>Warum ist die Möglichkeit dennoch nützlich?</p>
<ul>
<li>
<p>In Java kann man nur von einer Klasse erben, aber viele <span class='alert'>Interfaces</span>
implementieren. In C++ gibt es keine Interfaces ...</p>
<p>=&gt; Interfaces mit abstrakten Klassen Interfaces simulieren</p>
<p>=&gt; Mehrfachvererbung!</p>
</li>
</ul>
<p>Tatsächlich dürfen Java-Interfaces mittlerweile auch Verhalten implementieren
und vererben, wodurch eine ähnliche Situation wie hier in C++ entsteht und es
ausgefeilte Regeln für die Konfliktauflösung braucht. Allerdings ist das in
Java auf Verhalten beschränkt, d.h. Attribute (Zustand) ist in Java-Interfaces
(noch) nicht erlaubt.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p><code>public</code>-Vererbung in C++: <code>Subklasse : public Superklasse</code></p>
</li>
<li>
<p>Keine gemeinsame Oberklasse wie <code>Object</code>, kein <code>super</code></p>
</li>
<li>
<p>Verkettung von Operatoren und *struktoren</p>
</li>
<li>
<p>Abstrakte Klassen in C++</p>
</li>
<li>
<p>Statische und dynamische Polymorphie in C++</p>
<ul>
<li>Methoden in Basisklasse als <code>virtual</code> deklarieren</li>
<li>Dyn. Polymorphie nur mittels Pointer/Referenzen</li>
<li>Slicing in C++ (bei Call-by-Value)</li>
</ul>
</li>
<li>
<p>Konzept der Mehrfachvererbung</p>
</li>
<li>
<p>Problem bei rautenförmiger Vererbungsbeziehung: Attribute und Methoden mehrfach vorhanden</p>
</li>
<li>
<p>Virtuelle Basisklassen: Gemeinsam genutzte Attribute nur noch einfach vorhanden</p>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Destruktoren und Vererbung</strong></p>
<p>Welcher Destruktor würde im folgenden Beispiel aufgerufen?!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Student <span style="color:#f92672">*</span>s3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Student(<span style="color:#e6db74">&#34;Holger&#34;</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>Person  <span style="color:#f92672">*</span>p  <span style="color:#f92672">=</span> s3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;</span></span></code></pre></div>
<p><strong>Vererbung</strong></p>
<ul>
<li>Welche Formen der (einfachen) Vererbung gibt es in C++ neben der
<code>public</code>-Form noch? Was bewirken diese Formen?</li>
<li>Warum wird in C++ die <code>public</code>-Form der Vererbung vorgezogen
(zumindest, wenn man dynamische Polymorphie nutzen will)?</li>
<li>Wie müssen Konstruktoren/Destruktoren richtig verkettet werden?</li>
<li>Arbeiten Sie das Beispiel auf S. 274 im <a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/index.html#id_Breymann2011">[Breymann2011]</a>:
&quot;Der C++ Programmierer&quot; durch.</li>
</ul>
<p><strong>Virtuelle Methoden, Dynamische Polymorphie in C++</strong></p>
<ol>
<li>Was sind virtuelle Methoden und wie setze ich diese ein?</li>
<li>Wozu brauche ich in C++ virtuelle Klassen? Was muss beachtet werden?</li>
<li>Was passiert in C++, wenn eine virtuelle Methode innerhalb von Konstruktoren
verwendet wird? Schreiben Sie ein kurzes Programm zur Verdeutlichung.</li>
<li>Wie verhält es sich mit der Problematik aus (a) in Java?</li>
<li>Wie unterscheiden sich in C++ virtuelle und nicht virtuelle Destruktoren?
Schreiben Sie ein kurzes Programm zur Verdeutlichung.</li>
<li>Was passiert, wenn in C++ aus einem Destruktor heraus eine virtuelle
Methode aufgerufen wird?</li>
</ol>
<p><em>Hinweis:</em>
Möglicherweise müssen jeweils mehrere Fälle betrachtet werden!</p>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>C&#43;&#43;: Templates</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>In C++ können Funktionen über <strong>Funktions-Templates</strong> definiert werden. Dafür stellt man
ein <code>template &lt;typename T&gt;</code> mit einer Aufzählung <code>typename T</code> aller Template-Parameter der
Funktionsdefinition voran. In der Funktion kann man dann den Typ <code>T</code> wie einen normalen
anderen Typ nutzen.</p>
<p>Funktions-Templates sind (vollständig) spezialisierbar. Dazu wiederholt man die komplette
Funktionsdefinition (inkl. der dann leeren Template-Deklaration <code>template &lt;&gt;</code>) und legt alle
Template-Parameter über die Funktionssignatur fest. Alle Spezialisierungen müssen nach dem
eigentlichen (&quot;primären&quot;) Funktions-Template formuliert werden.</p>
<p>Funktions-Templates sind überladbar mit &quot;normalen&quot; Funktionen und anderen Funktions-Templates.</p>
<p>Beim Aufruf kann man die Template-Parameter entweder selbst festlegen (über eine Auflistung der
Typen in spitzen Klammern hinter dem Funktionsnamen) oder den Compiler inferieren lassen. Dabei
wird die am besten &quot;passende&quot; Variante genutzt:</p>
<ol>
<li>Zuerst die <strong>exakt</strong> passende normale Funktion,</li>
<li>dann ein passendes spezialisiertes Template (bei mehreren passenden spezialisierten
Templates das am meisten spezialisierte Template),</li>
<li>dann das allgemeine (&quot;primäre&quot;) Template,</li>
<li>ansonsten die normale Funktion mit impliziten Casts.</li>
</ol>
<p>In C++ können Klassen als <strong>Klassen-Templates</strong> definiert werden. Dafür stellt man ein
<code>template &lt;typename T&gt;</code> mit einer Aufzählung <code>typename T</code> aller Template-Parameter der
Klassendefinition voran. In der Klasse kann man dann den Typ <code>T</code> wie einen normalen
anderen Typ nutzen. Bei der Implementierung der Methoden außerhalb der Klassendeklaration
muss die Template-Deklaration (<code>template &lt;typename T&gt;</code>) wiederholt werden.</p>
<p>Klassen-Templates sind spezialisierbar (vollständig und partiell). Dazu wiederholt man
die komplette Klassendefinition (inkl. der Template-Deklaration <code>template &lt;typename T&gt;</code>)
und entfernt aus der Template-Deklaration alle Typen, die man konkret festlegen möchte.
Hinter dem Klassennamen werden dann in spitzen Klammern alle Typen (verbleibende
Typ-Parameter aus der Template-Deklaration sowie die konkretisierten Typen) in der
Reihenfolge angegeben, wie sie im primären Template vorkamen. Spezialisierungen müssen
nach dem eigentlichen (&quot;primären&quot;) Klassen-Template formuliert werden.</p>
<p>Klassen- und Funktions-Templates können gemischt werden.</p>
<p>Bei der Instantiierung werden die Template-Parameter in spitzen Klammern hinter dem
Klassennamen spezifiziert.</p>
<p>Template-Parameter können einen konkreten (aufzählbaren) Typ haben (beispielsweise
<code>int</code>). Template-Parameter können Default-Werte haben.</p>
<p>Im Unterschied zu Java gibt es <strong>keine</strong> Type-Erasure. Der C++-Compiler stellt je <strong>instantiiertem</strong>
Template eine <em>konkrete</em> Funktion bzw. Klasse bereit! Im resultierenden Code sind also nur diejenigen
Funktionen und Klassen enthalten, die aus einem tatsächlichen Aufruf resultieren, das Template selbst
ist nicht im Code enthalten. Dies gilt auch für Bibliotheken, weshalb sich diese beiden Konzepte etwas
&quot;quer liegen&quot;.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/cOmV_2OTG5k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL C++: Vererbung und Polymorphie</a></li></ul>
  </div>
</div>




    
    
    
    






    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Unterschied zu Java bei der Nutzung von Templates</li> <li>(K3) Erstellen und spezialisieren von Funktions-Templates</li> <li>(K3) Unterschied zwischen überladenen Funktionen und Funktions-Templates</li> <li>(K3) Aufruf (Nutzung) von Funktions-Templates</li> <li>(K2) Unterschied zu Java bei der Nutzung von Templates</li> <li>(K3) Erstellen und spezialisieren von Klassen-Templates</li> <li>(K3) Nutzung von Methoden-Templates innerhalb von Klassen-Templates</li> <li>(K3) Aufruf (Nutzung) von Klassen-Templates</li></ul>
  </div>
</div>




    <h2 id="vergleichsfunktion-für-zwei-integer">Vergleichsfunktion für zwei Integer?</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Und für <code>double</code>?</li>
<li>Und für <code>string</code>?</li>
<li>...</li>
</ul>
<p>=&gt; <span class='alert'>Präprozessor-Makro?</span></p>
<p>=&gt; <span class='alert'>Funktionen überladen?</span></p>
<ul>
<li><strong>Überladen von Funktionen</strong>:
<ul>
<li>Ähnliche Funktionalität für unterschiedliche Datentypen</li>
<li>Mühselig, wenn <span class='alert'>exakt gleiche</span> Funktionalität!</li>
</ul>
</li>
<li>(bessere) <strong>Antwort</strong>: Funktions-Templates
<ul>
<li>Templates: Funktionen mit parametrisierten Datentypen</li>
<li>Deklaration/Definition für (zunächst) unbestimmte Datentypen</li>
<li>Bei Verwendung der Funktion:</li>
<li>Konkretisierung der Datentypen</li>
<li>Compiler erzeugt automatisch passende Funktionsinstanz</li>
</ul>
</li>
</ul>
<h2 id="definition-von-funktions-templates">Definition von Funktions-Templates</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>
<p>Statt <code>typename</code> kann auch <code>class</code> geschrieben werden</p>
</li>
<li>
<p>Konvention:</p>
<ul>
<li><code>typename</code> wenn sowohl Klassen als auch Basistypen</li>
<li><code>class</code> falls eher Klassen-Typen</li>
</ul>
<p>=&gt; <code>class</code> gilt als veraltet, deshalb immer <code>typename</code> verwenden!</p>
</li>
<li>
<p>Bei mehreren Typen &quot;<code>typename NAME</code>&quot; wiederholen
(Komma-separierte Liste in <code>&lt;</code> und <code>&gt;</code>)</p>
<p>beispielsweise so: (Achtung, soll nur die Verwendung demonstrieren, hat sonst keinen Sinn)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2, <span style="color:#66d9ef">typename</span> T3<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T1 cmp(<span style="color:#66d9ef">const</span> T2 <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T3 <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
<p>Vorsicht: Im Beispiel oben muss <code>operator&lt;</code> für die verwendeten Typen
<code>T</code> implementiert sein! (sonst Fehler zur Compile-Zeit)</p>
<h2 id="bestimmung-der-template-parameter-i-typ-inferenz">Bestimmung der Template-Parameter I: Typ-Inferenz</h2>
<p>Das Funktions-Template wird wie eine normale Funktion aufgerufen ...
=&gt; Der Compiler inferiert Typen und erzeugt passende Funktionsinstanz(en).</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    cmp(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">10</span>);                         <span style="color:#75715e">// cmp(int, int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp(<span style="color:#ae81ff">2.2</span>, <span style="color:#ae81ff">10.1</span>);                     <span style="color:#75715e">// cmp(double, double)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp(string(<span style="color:#e6db74">&#34;abc&#34;</span>), string(<span style="color:#e6db74">&#34;ABC&#34;</span>));  <span style="color:#75715e">// cmp(string, string)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3.4</span>);                        <span style="color:#75715e">// Compiler-FEHLER!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>Vorsicht bei Typ-Inferenz: Typen müssen <em>exakt</em> passen!</p>
<h2 id="bestimmung-der-template-parameter-ii-explizite-angabe">Bestimmung der Template-Parameter II: Explizite Angabe</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    cmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;A&#39;</span>);     <span style="color:#75715e">// cmp(int, int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3.4</span>);       <span style="color:#75715e">// cmp(int, int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>Bei expliziter Angabe der Typen beim Aufruf (<code>cmp&lt;int&gt;</code>) kann der Compiler automatisch casten.</p>
<h2 id="typ-inferenz-und-explizite-bestimmung-mischen">Typ-Inferenz und explizite Bestimmung mischen</h2>
<ul>
<li>Compiler nutzt die vorgegebenen Typ-Parameter, ...</li>
<li>... inferiert die restlichen, und ...</li>
<li>... castet notfalls die Parameter</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2, <span style="color:#66d9ef">typename</span> T3<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> fkt(T2 a, T3 b, T2 c, <span style="color:#66d9ef">int</span> d) { ... }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    fkt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>, <span style="color:#e6db74">&#34;HUHU&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">99</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>=&gt; In Parameterliste nicht vorkommende Typ-Parameter <strong>explizit</strong> angeben!</p>
<ul>
<li>Reihenfolge der Angabe der Typen in spitzen Klammern beim Aufruf wie in
Template-Deklaration</li>
<li>Wenn ein Typ-Parameter nicht in der Parameterliste der Funktion vorkommt, ist
eine Inferenz für den Compiler unmöglich. Deshalb <strong>muss</strong> dieser Typ beim
Aufruf explizit in der Liste mit den spitzen Klammern angegeben werden!</li>
<li>Im Beispiel oben:
<ul>
<li>
<p><code>fkt&lt;a, b, c&gt;(...)</code>: <code>a</code> wäre der Typ für <code>T1</code>, <code>b</code> für <code>T2</code>, <code>c</code> für <code>T3</code></p>
</li>
<li>
<p>Mit <code>fkt&lt;..., int&gt;(...)</code> beim Aufruf wird <code>T2</code> zu <code>int</code> und damit für
Parameter <code>c</code> der Char als <code>int</code> interpretiert (<code>T3</code> wird inferiert)</p>
<p>Ohne <code>&lt;..., int&gt;</code> beim Aufruf gibt es ein Problem beim Erkennen von <code>T2</code>: <code>int</code> vs. <code>char</code> (<code>a=42</code>, <code>c='a'</code>) ...</p>
</li>
</ul>
</li>
</ul>
<h2 id="typ-inferenz-funktioniert-nicht-immer">Typ-Inferenz funktioniert nicht immer!</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T zero() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> zero(); <span style="color:#75715e">// Fehler: couldn&#39;t deduce template parameter &#39;T&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    y <span style="color:#f92672">=</span> zero<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// korrekter Aufruf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>Die Funktion hat keine Parameter - der Compiler hat also keine Chance, den Typ <code>T</code> zu
inferieren. In diesem Fall <em>muss</em> der Typ beim Aufruf explizit angegeben werden.</p>
<h2 id="spezialisierung-von-funktions-templates">Spezialisierung von Funktions-Templates</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Primaeres Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">abs</span>(a)<span style="color:#f92672">&lt;</span>abs(b);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Spezialisierte Templates <span class='alert'><strong>nach</strong></span> &quot;primärem&quot; Template definieren</p>
<p><strong>Achtung</strong>: Reihenfolge der Deklaration/Definition ist <em>wichtig</em>. Immer zuerst das
allgemeine (&quot;primäre&quot;) Template definieren, danach dann die Spezialisierungen!
Anderenfalls gibt es &quot;seltsame&quot; Fehlermeldungen vom Compiler oder sogar seltsames
Verhalten.</p>
<p><strong>Achtung</strong>: Im Unterschied zu Klassen-Templates können Funktions-Templates nur
<strong>vollständig</strong> spezialisiert werden (d.h. bei mehreren Template-Parametern müssen
dann <em>alle</em> Template-Parameter konkret spezifiziert werden)!</p>
<p><em>Anmerkung</em>: Die Angabe der Typen in spitzen Klammern nach dem Funktionsnamen ist
freiwillig, so lange <em>alle</em> Typ-Parameter in der Parameterliste der Funktion auftauchen.
Man könnte die obige Spezialisierung also auch so schreiben (<code>cmp(</code> statt <code>cmp&lt;int&gt;(</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">abs</span>(a)<span style="color:#f92672">&lt;</span>abs(b);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="alternativ-überladen-der-funktions-templates-mit-normalen-funktionen">Alternativ: Überladen der Funktions-Templates mit normalen Funktionen</h3>
<p>Überladen mit normalen Funktionen funktioniert wie bei spezialisierten
Templates, d.h. auch hier zuerst das primäre Template definieren, danach
eventuelle Spezialisierungen und danach Überladungen mit normalen Funktionen.</p>
<p>Allerdings gibt es Unterschiede für eventuell nötige Typumwandlungen der
Parameter beim Aufruf der Funktionen:</p>
<ul>
<li>In gewöhnlichen Funktionen sind automatische Typumwandlungen möglich</li>
<li>In (spezialisierten) Templates sind keine automatischen Typumwandlungen
erlaubt (sofern man mit Typ-Inferenz arbeitet, d.h. die Template-Typen
nicht beim Aufruf explizit angegeben werden)</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(T a, T b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> abs(a)<span style="color:#f92672">&lt;</span>abs(b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    cmp(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>);          <span style="color:#75715e">// true:  überladene normale Funktion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3.4</span>);        <span style="color:#75715e">// FALSE: überladene normale Funktion (Cast)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3.4</span>);   <span style="color:#75715e">// FALSE: Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<h3 id="aufruf-compiler-nimmt-die-am-besten-passende-variante">Aufruf: Compiler nimmt die am besten &quot;passende&quot; Variante:</h3>
<ul>
<li>Keine Template-Parameter beim Aufruf angegeben (d.h. Typ-Inferenz):
<ol>
<li>Zuerst <strong>exakt</strong> passende normale Funktion,</li>
<li>dann passendes spezialisiertes Template (bei mehreren passenden spezialisierten
Templates das am meisten spezialisierte Template, ohne Casts),</li>
<li>dann das allgemeine (&quot;primäre&quot;) Template (ohne Casts),</li>
<li>ansonsten normale Funktion mit impliziten Casts</li>
</ol>
</li>
<li>Template-Parameter beim Aufruf angegeben: am besten passendes Template</li>
</ul>
<p><em>Hinweis</em>: Durch reine Deklaration von Spezialisierungen (d.h. ohne die
entsprechende Implementierung) lässt sich die Instantiierung einer
Templatefunktion für bestimmte Typen verhindern. Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> cmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b);</span></span></code></pre></div>
<p>Damit könnte man die <code>cmp</code>-Funktion nicht mehr für <code>int</code> benutzen (Compiler-
bzw. Linker-Fehler).</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/funktionsTemplates.cpp" target="_blank"><span class="title">Konsole: funktionsTemplates.cpp</span></a></span></div>
<h2 id="klassen-templates-in-c">Klassen-Templates in C++</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span> {
</span></span><span style="display:flex;"><span>    Matrix(<span style="color:#66d9ef">unsigned</span> rows <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">unsigned</span> cols <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> xyField;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><em>Hinweis</em>:
Template-Parameter innerhalb von Template-Parametern verursachen bei den
schließenden spitzen Klammern u.U. Parser-Probleme. Diese lassen sich durch
ein extra Leerzeichen (hat sonst keine Funktion!) umgehen: Statt
<code>vector&lt;vector&lt;T&gt;&gt; xyField;</code> besser <code>vector&lt;vector&lt;T&gt; &gt; xyField;</code>
schreiben.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m1;
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> m2(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Template-Parameter gehören zur Schnittstelle und müssen bei der Instantiierung
angegeben werden. <code>Matrix m;</code> würde im obigen Beispiel <strong>nicht</strong> funktionieren.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Matrix<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Matrix(<span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols) { ... }</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/matrix.cpp" target="_blank"><span class="title">Beispiel: matrix.cpp</span></a></span></div>
<h3 id="klassen-templates-in-c-variante-mit-konstanten">Klassen-Templates in C++ (Variante mit Konstanten)</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span> {
</span></span><span style="display:flex;"><span>    Matrix();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> xyField;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Template-Parameter können neben Typen auch konstante Werte (Basisdatentypen,
außer <code>float</code> und <code>double</code>) sein. Innerhalb der Klasse <code>Matrix</code> kann auf
die Werte von <code>rows</code> und <code>cols</code> zugegriffen werden.</p>
<p><em>Achtung</em>: <code>rows</code> und <code>cols</code> sind <strong>keine</strong> Attribute der Klasse <code>Matrix</code>!</p>
<p><em>Hinweis</em>: Konstanten als Template-Parameter funktioniert auch bei
Funktions-Templates.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> m1;
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> m2;
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span>string, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> m3;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/matrix2.cpp" target="_blank"><span class="title">Beispiel: matrix2.cpp</span></a></span></div>
<h3 id="beispiel-konstanten-als-template-parameter">Beispiel: Konstanten als Template-Parameter</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> I<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> print() {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> I;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span><span style="color:#f92672">&gt;</span>();</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> u<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> { X <span style="color:#f92672">=</span> u };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> MyClass<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;::</span>X <span style="color:#f92672">&lt;&lt;</span> endl;</span></span></code></pre></div>
<ul>
<li>Konstante muss explizit übergeben werden</li>
<li>Wert muss eine zur Compile-Zeit bekannte Konstante sein</li>
<li>Nur aufzählbare Typen für derartige Konstanten erlaubt
(z.B. <code>int</code>, aber nicht <code>double</code>)</li>
</ul>
<p><em>Anmerkung</em>:
Durch Konstruktion mit dem anonymen <code>enum</code> in der Klasse <code>MyClass</code> wird der
Wert der Konstanten &quot;gespeichert&quot; und kann später (von außen) abgefragt werden.
(Innerhalb der Klasse selbst können Sie natürlich jederzeit auf den Wert von
<code>u</code> zugreifen.)</p>
<p>Wollte man dies über ein normales Attribut erledigen, sähe der Code deutlich
komplexer aus (zusätzlich zur oben gezeigten Variante mit dem <code>enum</code> einmal
als statisches Attribut <code>Y</code> und einmal als &quot;normales&quot; Attribut <code>Z</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> u<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> { X <span style="color:#f92672">=</span> u };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> Y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> Z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyClass() <span style="color:#f92672">:</span> Z(u) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> u<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> MyClass<span style="color:#f92672">&lt;</span>u<span style="color:#f92672">&gt;::</span>Y <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> MyClass<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;::</span>X <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> MyClass<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;::</span>Y <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> MyClass<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>().Z <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Falls man mit <code>::</code> zugreifen wollte, müsste das Attribut <code>static</code> sein und
entsprechend außerhalb der Klasse initialisiert werden. Für ein &quot;normales&quot;
Attribut braucht man dann einen extra Konstruktor und muss den Aufruf dann
extra klammern: <code>MyClass&lt;2&gt;().Z</code> statt <code>MyClass&lt;2&gt;.Z</code>.</p>
<p>Die Variante mit dem <code>enum</code> werden Sie entsprechend sehr häufig in C++ finden!</p>
<h3 id="klassen-templates-mit-defaults">Klassen-Templates mit Defaults</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">unsigned</span> rows <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">unsigned</span> cols <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span> {
</span></span><span style="display:flex;"><span>    Matrix();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> xyField;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;&gt;</span> m1;    <span style="color:#75715e">// Leere spitze Klammern Pflicht!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> m2;
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> m3;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Leere spitze Klammern bei Klassen-Templates mit Default-Parameter Pflicht!</p>
<p><em>Hinweis</em>: Defaults für Template-Parameter waren zunächst nur für Klassen-Templates
erlaubt. Seit C++11 kann man solche Defaults auch bei Funktions-Templates
einsetzen.</p>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/matrix3.cpp" target="_blank"><span class="title">Beispiel: matrix3.cpp</span></a></span></div>
<h2 id="klassen-templates-in-c-spezialisieren">Klassen-Templates in C++ spezialisieren</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span> {
</span></span><span style="display:flex;"><span>    Matrix(<span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols);
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span> vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> xyField;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span><span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Matrix(<span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols);
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span> vector<span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> xyField;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div style="text-align: right;"><span class="badge cstyle default"><span class="badge-content">Hinweis auf Implementierung außerhalb der Klasse</span></span></div>
<p><strong>ACHTUNG</strong>: Implementierung außerhalb der Klasse: Bei den Methoden des voll
spezialisierten Templates das &quot;<code>template&lt;&gt;</code>&quot; <strong>weglassen</strong>! Alles andere ist
ein Syntax-Fehler.</p>
<p>Der Grund dafür bleibt ein Geheimnis des C++-Standards ... ;-)</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Implementierung fuer primaeres Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Matrix<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Matrix(<span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols) { ... }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implementierung fuer vollstaendig spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Matrix<span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;::</span>Matrix(<span style="color:#66d9ef">unsigned</span> rows, <span style="color:#66d9ef">unsigned</span> cols) { ... }</span></span></code></pre></div>
<h3 id="partielle-spezialisierung">Partielle Spezialisierung</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Array</span> {
</span></span><span style="display:flex;"><span>    Array();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>T1<span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>T2<span style="color:#f92672">&gt;</span> w;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Array</span><span style="color:#f92672">&lt;</span>T, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Array();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> w;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p><strong>ACHTUNG</strong>: Implementierung außerhalb der Klasse: Bei den Methoden des partiell
spezialisierten Templates muss das &quot;<code>template&lt;T&gt;</code>&quot; wieder benutzt werden!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Implementierung fuer primaeres Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Array<span style="color:#f92672">&lt;</span>T1, T2<span style="color:#f92672">&gt;::</span>Array() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implementierung fuer partiell spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Array<span style="color:#f92672">&lt;</span>T, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>Array() {}</span></span></code></pre></div>
<h3 id="vergleich-verschiedene-spezialisierungen">Vergleich verschiedene Spezialisierungen</h3>
<p>Allgemeine Templates vs. partiell spezialisierte Templates vs. vollständig spezialisierte Templates</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Primaeres (allgemeines) Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> line, <span style="color:#66d9ef">unsigned</span> column<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Matrix();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Partiell spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> line<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span><span style="color:#f92672">&lt;</span>line, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Matrix();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Vollstaendig spezialisiertes Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Matrix</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Matrix();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Aufrufe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> matrix;        <span style="color:#75715e">// allg. Template
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> vector;       <span style="color:#75715e">// partiell spez. Templ.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Matrix<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> dreiKreuzDrei; <span style="color:#75715e">// vollst. spez. Templ.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implementierung
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> line, <span style="color:#66d9ef">unsigned</span> column<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Matrix<span style="color:#f92672">&lt;</span>line, column<span style="color:#f92672">&gt;::</span>Matrix() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;allgemeines Template&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> line<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Matrix<span style="color:#f92672">&lt;</span>line, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;::</span>Matrix() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;partiell spezialisiertes Template&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Matrix<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;::</span>Matrix() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vollstaendig spezialisiertes Template&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }</span></span></code></pre></div>
<p>Regel: Das am meisten spezialisierte Template wird verwendet.</p>
<h2 id="mischen-von-klassen--und-funktions-templates">Mischen von Klassen- und Funktions-Templates</h2>
<p>Sie können innerhalb eines Klassen-Templates auch ein Funktions-Template
(Methoden-Template) definieren. Bei der Implementierung außerhalb der
Klasse müssen entsprechend alle Template-Deklarationen wiederholt werden!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">unsigned</span> n<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Array</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> { size <span style="color:#f92672">=</span> n };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> copy_from(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    T data[n];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">unsigned</span> n<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Array<span style="color:#f92672">&lt;</span>T,n<span style="color:#f92672">&gt;::</span>copy_from(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>c) { ... }</span></span></code></pre></div>
<h2 id="templates-java-vs-c">Templates: Java vs. C++</h2>
<ul>
<li>
<p>Templates sind nur <strong>Schablonen</strong>!</p>
<p>Die Definitionen der Templates werden nicht in den Object-Code kompiliert!
Erst bei der Instantiierung von Templates wird durch den Compiler eine
passende Instanz erzeugt und im Object-Code zur Nutzung abgelegt.</p>
</li>
<li>
<p><span class='alert'><strong>Unterschied zu Java</strong></span></p>
<ul>
<li>C++: Für <strong>jeden</strong> Aufruf/Typ eine passende <strong>Instanz</strong> (!)</li>
<li>Java: Nur <strong>eine</strong> Klasse mit gemeinsamen Obertyp</li>
</ul>
</li>
<li>
<p>Offener Code: <span class='alert'><strong>Templates im <code>.h</code>-File implementieren!</strong></span></p>
<p>Ohne die Template-Definition kann der Compiler keine Instanzen anlegen!</p>
</li>
<li>
<p>Bibliotheken und Templates passen nicht recht</p>
<p>Templates werden immer bei der ersten Verwendung instantiiert! Wird ein
Template nicht im zu kompilierenden Code verwendet, dann generiert der
Compiler auch nichts, was man in den Objektdateien finden könnte ...</p>
<ul>
<li>
<p>Nur instantiierte Templates sind in einer dynamischen/statischen
Bibliothek enthalten!</p>
</li>
<li>
<p>Falls Einsatz nur für wenige Typen vorgesehen
=&gt; Explizite Instantiierung:</p>
<ul>
<li>
<p>Entweder mit &quot;<code>template</code>&quot;: <code>template class Matrix&lt;5,5&gt;;</code>, oder</p>
</li>
<li>
<p>mit &quot;<code>typedef</code>&quot;: <code>typedef Matrix&lt;5,5&gt; Matrix5x5;</code></p>
<p>=&gt; Dann aber nur in exakt diesen Versionen in der Bibliothek
enthalten und entsprechend nur so nutzbar (sofern die
Template-Definition nicht zur Verfügung steht)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Generische Programmierung (Funktions-Templates)</p>
<ul>
<li><code>template &lt;typename T&gt;</code> der Funktionsdefinition voranstellen</li>
<li>Funktions-Templates sind spezialisierbar und überladbar</li>
<li>Aufruf: Compiler nimmt die am besten &quot;passende&quot; Variante</li>
</ul>
</li>
<li>
<p>Generische Programmierung (Klassen-Templates)</p>
<ul>
<li>Funktionsweise analog zu Funktions-Templates</li>
<li>Bei Implementierung außerhalb der Deklaration: Template-Deklaration mitführen!</li>
<li>Klassen-Templates lassen sich partiell spezialisieren</li>
</ul>
</li>
<li>
<p>Compiler stellt je instantiiertes Template eine konkrete Funktion/Klasse bereit</p>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Funktions-Templates</strong></p>
<ul>
<li>Wie kann eine Funktion als Funktions-Template definiert werden?</li>
<li>Wie wird ein Funktions-Template benutzt, d.h. wie wird es aufgerufen?
Worin liegt der Unterschied zu Java?</li>
<li>Wie kann ein Funktions-Template spezialisiert werden? Was ist dabei zu beachten?</li>
<li>Kann man Funktions-Templates überladen?</li>
<li>Worin liegt der Unterschied zwischen einem spezialisierten Funktions-Template
und einem überladenen Funktions-Template?</li>
</ul>
<p><strong>Funktions-Templates in C++</strong></p>
<ol>
<li>
<p>Schreiben Sie in C++ eine Funktion <code>invert()</code>, die zu einem übergebenen
numerischen Wert den negativen Wert zurückgibt. Realisieren Sie die
Funktion als Funktions-Template.</p>
<p>Testen Sie Ihre Implementierung mit den Typen <code>int</code>, <code>double</code> und <code>short</code>.</p>
</li>
<li>
<p>Spezialisieren Sie das eben erstellte Funktions-Template, so daß <code>invert()</code>
auch für <code>string</code> aufgerufen werden kann. In diesem Fall soll der String
umgekehrt werden und zurückgeliefert werden, d.h. für die Eingabe von
&quot;abcde&quot; soll &quot;edcba&quot; zurück geliefert werden.</p>
<p>Testen Sie die Funktionen wiederum mit <code>int</code>, <code>double</code>, <code>short</code> und nun
auch <code>string</code>.</p>
</li>
<li>
<p>Schreiben Sie ein weiteres Funktions-Template <code>string getType(T t)</code> mit
Template-Spezialisierungen, die den Typ des Parameters <code>t</code> als String
zurückgibt. Für nicht bekannte Typen soll der String &quot;unbekannter Typ&quot;
zurückgeliefert werden.</p>
<p>Implementieren Sie mind. 3 Spezialisierungen.</p>
<p><em>Hinweis:</em> Verwenden Sie an dieser Stelle keine explizite Typüberprüfung (in
der Funktion)! Realisieren Sie die Reaktion auf unterschiedliche
Parametertypen ausschließlich mit Hilfe von Templates.</p>
</li>
<li>
<p>Erklären Sie folgenden Code-Schnipsel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">// Definition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T2, <span style="color:#66d9ef">typename</span> T1<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> f(T1 a, T2 b, <span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Aufruf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">99</span>, <span style="color:#e6db74">&#34;Hello World&#34;</span>, <span style="color:#ae81ff">42</span>);</span></span></code></pre></div>
</li>
<li>
<p>Erklären Sie nun folgenden Code-Schnipsel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T2, <span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T3<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> fkt(T2 a, T3 b, T2 c, <span style="color:#66d9ef">int</span> d) { ... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fkt</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c, <span style="color:#66d9ef">int</span> d) { ... }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    fkt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">42</span>, <span style="color:#e6db74">&#34;HUHU&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">99</span>);
</span></span><span style="display:flex;"><span>    fkt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    fkt(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ol>
<p><strong>Klassen-Templates und partielle Spezialisierung</strong></p>
<p>Definieren Sie ein Klassen-Template zum Umgang mit Vektoren. Diese sollen
Elemente eines unbestimmten Typs (Typ-Variable) aufnehmen. Die Größe des
Vektors soll ebenfalls als Typ-Variable in die Template-Definition eingehen.
Definieren Sie den <code>operator*</code> für das Skalarprodukt von zwei Vektoren.</p>
<p>Erstellen Sie eine partielle Spezialisierung des Klassen-Templates zur
Repräsentation von einstelligen Vektoren (Skalare).</p>
<p>Schreiben Sie ein <code>main()</code>-Funktion, instantiieren einige Vektoren und berechnen
Sie die Skalarprodukte.</p>
<p><strong>Beispiel aus dem echten Leben</strong></p>
<p>Erklären Sie das folgende Beispiel eines Klassen-Templates <code>RingBuffer</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, size_t size, <span style="color:#66d9ef">typename</span> alloc_t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>allocator<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RingBuffer</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> AllocatorType alloc_t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    RingBuffer(<span style="color:#66d9ef">const</span> alloc_t <span style="color:#f92672">&amp;</span>rb_allocator <span style="color:#f92672">=</span> alloc_t());
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>RingBuffer();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeBuffer</span>(T <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    alloc_t m_allocator;
</span></span><span style="display:flex;"><span>    size_t count;
</span></span><span style="display:flex;"><span>    size_t head;
</span></span><span style="display:flex;"><span>    T <span style="color:#f92672">**</span>elems;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Breymann2011'>[Breymann2011] <strong>Der C++ Programmierer</strong><br>Breymann, U., Hanser, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-446-42691-7' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-446-42691-7</a>.</li> <li id='id_cppreference.com'>[cppreference.com] <a href='https://en.cppreference.com/w/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C and C++ Reference</strong></a><br>, cppreference.com.</li> <li id='id_cprogramming.com'>[cprogramming.com] <a href='https://www.cprogramming.com/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>C Programming and C++ Programming</strong></a><br>Allain, A. und Hoffer, A..</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
        </div>
      </main>
    </div>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/clipboard.min.js?1739788418" defer></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/perfect-scrollbar.min.js?1739788418" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/mathjax/tex-mml-chtml.js?1739788418"></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/theme.js?1739788418" defer></script>
  </body>
</html>
