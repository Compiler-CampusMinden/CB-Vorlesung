<!DOCTYPE html>
<html lang="de-DE" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.135.0">
    <meta name="generator" content="Relearn 6.4.1">
    <meta name="description" content="In der syntaktischen Analyse arbeitet ein Parser mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird geprüft, ob gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser erzeugt dabei den Parse-Tree. Man kann verschiedene Parser unterscheiden, beispielsweise die LL- und die LR-Parser.
CFG Parser mit ANTLR generieren">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Syntaktische Analyse">
    <meta name="twitter:description" content="In der syntaktischen Analyse arbeitet ein Parser mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird geprüft, ob gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser erzeugt dabei den Parse-Tree. Man kann verschiedene Parser unterscheiden, beispielsweise die LL- und die LR-Parser.
CFG Parser mit ANTLR generieren">
    <meta property="og:url" content="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing.html">
    <meta property="og:title" content="Syntaktische Analyse">
    <meta property="og:description" content="In der syntaktischen Analyse arbeitet ein Parser mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird geprüft, ob gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser erzeugt dabei den Parse-Tree. Man kann verschiedene Parser unterscheiden, beispielsweise die LL- und die LR-Parser.
CFG Parser mit ANTLR generieren">
    <meta property="og:locale" content="de_DE">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Syntaktische Analyse">
    <meta itemprop="description" content="In der syntaktischen Analyse arbeitet ein Parser mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird geprüft, ob gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser erzeugt dabei den Parse-Tree. Man kann verschiedene Parser unterscheiden, beispielsweise die LL- und die LR-Parser.
CFG Parser mit ANTLR generieren">
    <meta itemprop="wordCount" content="51">
    <title>Syntaktische Analyse</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing.html" rel="canonical" type="text/html" title="Syntaktische Analyse">

    

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/images/logo.png?1739788418" rel="icon" type="image/png">

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fontawesome-all.min.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fontawesome-all.min.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/nucleus.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/auto-complete.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/auto-complete.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/perfect-scrollbar.min.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fonts.css?1739788418" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/fonts.css?1739788418" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/theme.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/theme-auto.css?1739788418" rel="stylesheet" id="R-variant-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/chroma-auto.css?1739788418" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/variant.css?1739788418" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/print.css?1739788418" rel="stylesheet" media="print">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/css/format-print.css?1739788418" rel="stylesheet">
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/variant.js?1739788418"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='.';
      window.relearn.relBaseUri='..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1360443';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.index_js_url="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/index.search.js?1739788418";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Syntaktische Analyse
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="syntaktische-analyse">Syntaktische Analyse</h1>

<p>In der syntaktischen Analyse arbeitet ein Parser mit dem Tokenstrom, der vom Lexer kommt.
Mit Hilfe einer Grammatik wird geprüft, ob gültige Sätze im Sinne der Sprache/Grammatik
gebildet wurden. Der Parser erzeugt dabei den Parse-Tree. Man kann verschiedene Parser
unterscheiden, beispielsweise die LL- und die LR-Parser.</p>
<ul class="children children-li children-sort-">
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg.html">CFG</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing.html">Parser mit ANTLR generieren</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Syntaktische Analyse</h1>
<article class="default">
<h1>CFG</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="far fa-file-powerpoint"></i> Annotierte Folien
  </div>
  <div class="box-content">
<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/frontend_parsing_cfg.ann.ba.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: CFG, LL-Parser</a></li></ul>
  </div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="endliche-automaten-reguläre-ausdrücke-reguläre-grammatiken-reguläre-sprachen">Endliche Automaten, reguläre Ausdrücke, reguläre Grammatiken, reguläre Sprachen</h2>
<ul>
<li>Wie sind DFAs und NFAs definiert?</li>
<li>Was sind reguläre Ausdrücke?</li>
<li>Was sind formale und reguläre Grammatiken?</li>
<li>In welchem Zusammenhang stehen all diese Begriffe?</li>
<li>Wie werden DFAs und reguläre Ausdrücke im Compilerbau eingesetzt?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="wofür-reichen-reguläre-sprachen-nicht">Wofür reichen reguläre Sprachen nicht?</h2>
<p>Für z. B. alle Sprachen, in deren Wörtern Zeichen über eine Konstante hinaus gezählt werden müssen. Diese Sprachen lassen sich oft mit Variablen im Exponenten beschreiben, die unendlich viele Werte annehmen können.</p>
<ul>
<li>
<p><span class="math align-center">$a^ib^{2*i}$</span> ist nicht regulär</p>
</li>
<li>
<p><span class="math align-center">$a^ib^{2*i}$</span> für <span class="math align-center">$0 \leq i \leq 3$</span> ist regulär</p>
</li>
<li>
<p>Wo finden sich die oben genannten Variablen bei einem DFA wieder?</p>
</li>
<li>
<p>Warum ist die erste Sprache oben nicht regulär, die zweite aber?</p>
</li>
</ul>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>PDAs: mächtiger als DFAs, NFAs</li>
<li>kontextfreie Grammatiken und Sprachen: mächtiger als reguläre Grammatiken und Sprachen</li>
<li>DPDAs und deterministisch kontextfreie Grammatiken: die Grundlage der Syntaxanalyse im Compilerbau</li>
<li>Der Einsatz kontextfreier Grammatiken zur Syntaxanalyse mittels Top-Down-Techniken</li>
</ul>
<h2 id="einordnung-erweiterung-der-automatenklasse-dfa-um-komplexere-sprachen-als-die-regulären-akzeptieren-zu-können">Einordnung: Erweiterung der Automatenklasse DFA, um komplexere Sprachen als die regulären akzeptieren zu können</h2>
<p>Wir spendieren den DFAs einen möglichst einfachen, aber beliebig großen, Speicher, um zählen und matchen zu können. Wir suchen dabei konzeptionell die &quot;kleinstmögliche&quot; Erweiterung, die die akzeptierte Sprachklasse gegenüber DFAs vergrößert.</p>
<ul>
<li>
<p>Der konzeptionell einfachste Speicher ist ein Stack. Wir haben keinen wahlfreien Zugriff auf die gespeicherten Werte.</p>
</li>
<li>
<p>Es soll eine deterministische und eine indeterministische Variante der neuen Automatenklasse geben.</p>
</li>
<li>
<p>In diesem Zusammenhang wird der Stack auch Keller genannt.</p>
</li>
</ul>
<h2 id="kellerautomaten-push-down-automata-pdas">Kellerautomaten (Push-Down-Automata, PDAs)</h2>
<p><strong>Def.:</strong> Ein Kellerautomat (PDA) <span class="math align-center">$P = (Q,\ \Sigma,\ \Gamma,\  \delta,\ q_0,\ \perp,\ F)$</span>
ist ein Septupel mit:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg/Def_PDA.png" alt="Definition eines PDAs" width="60%" height="auto">
    <figcaption><p>Definition eines PDAs</p></figcaption>
</figure>
<p>Ein PDA ist per Definition nichtdeterministisch und kann spontane Zustandsübergänge durchführen.</p>
<h2 id="was-kann-man-damit-akzeptieren">Was kann man damit akzeptieren?</h2>
<p>Strukturen mit paarweise zu matchenden Symbolen.</p>
<p>Bei jedem Zustandsübergang wird ein Zeichen (oder <span class="math align-center">$\epsilon$</span>) aus der Eingabe gelesen, ein Symbol von Keller genommen. Diese und das Eingabezeichen bestimmen den Folgezustand und eine Zeichenfolge, die auf den Stack gepackt wird. Dabei wird ein Symbol, (z. B. eines, das später mit einem Eingabesymbol zu matchen ist,) auf den Stack gepackt. Soll das automatisch vom Stack genommene Symbol auf dem Stack bleiben, muss es wieder gepusht werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Ein PDA für <span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-91665825043224079ed3cf144c88c3e6" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg/pda2.png?width=45%25&height=auto" style=" height: auto; width: 45%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91665825043224079ed3cf144c88c3e6"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg/pda2.png?width=45%25&height=auto"></a></p>
<h2 id="deterministische-pdas">Deterministische PDAs</h2>
<p><strong>Def.</strong> Ein PDA <span class="math align-center">$P = (Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ist <em>deterministisch</em>
<span class="math align-center">$: \Leftrightarrow$</span></p>
<ul>
<li>
<p><span class="math align-center">$\delta(q, a, X)$</span> hat höchstens ein Element für jedes <span class="math align-center">$q \in Q, a \in\Sigma$</span> oder <span class="math align-center">$(a = \epsilon$</span> und <span class="math align-center">$X \in \Gamma)$</span>.</p>
</li>
<li>
<p>Wenn <span class="math align-center">$\delta (q, a, x)$</span> nicht leer ist für ein <span class="math align-center">$a \in \Sigma$</span>, dann muss <span class="math align-center">$\delta (q, \epsilon, x)$</span> leer sein.</p>
</li>
</ul>
<p>Deterministische PDAs werden auch <em>DPDAs</em> genannt.</p>
<h2 id="der-kleine-unterschied">Der kleine Unterschied</h2>
<p><strong>Satz:</strong> Die von DPDAs akzeptierten Sprachen sind eine echte Teilmenge der von
PDAs akzeptierten Sprachen.</p>
<p>Die regulären Sprachen sind eine echte Teilmenge der von DPDAs akzeptierten Sprachen.</p>
<h1 id="kontextfreie-grammatiken-und-sprachen">Kontextfreie Grammatiken und Sprachen</h1>
<h2 id="kontextfreie-grammatiken">Kontextfreie Grammatiken</h2>
<p><strong>Def.</strong> Eine <em>kontextfreie (cf-)</em> Grammatik ist ein 4-Tupel <span class="math align-center">$G = (N, T, P, S)$</span> mit <span class="math align-center">$N, T, S$</span> wie in
(formalen) Grammatiken und <span class="math align-center">$P$</span> ist eine endliche Menge von Produktionen der Form:</p>
<p><span class="math align-center">$X \rightarrow Y$</span> mit <span class="math align-center">$X \in N, Y \in {(N \cup T)}^{\ast}$</span>.</p>
<p><span class="math align-center">$\Rightarrow, \overset{\ast}{\Rightarrow}$</span> sind definiert wie bei regulären Sprachen. Bei cf-Grammatiken nennt man die Ableitungsbäume oft <em>Parse trees</em>.</p>
<h2 id="beispiel-1">Beispiel</h2>
<span class="math align-center">$S \rightarrow a \mid S\ +\  S\ |\  S \ast S$</span>
<p>Ableitungsbäume für <span class="math align-center">$a + a \ast a$</span>:</p>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="nicht-jede-kontextfreie-grammatik-ist-eindeutig">Nicht jede kontextfreie Grammatik ist eindeutig</h2>
<p><strong>Def.:</strong> Gibt es in einer von einer kontextfreien Grammatik erzeugten Sprache ein
Wort, für das mehr als ein Ableitungsbaum existiert, so heißt diese Grammatik
<em>mehrdeutig</em>. Anderenfalls heißt sie <em>eindeutig</em>.</p>
<p><strong>Satz:</strong> Es ist nicht entscheidbar, ob eine gegebene kontextfreie Grammatik eindeutig ist.</p>
<p><strong>Satz:</strong> Es gibt kontextfreie Sprachen, für die keine eindeutige Grammatik existiert.</p>
<h2 id="kontextfreie-grammatiken-und-pdas">Kontextfreie Grammatiken und PDAs</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen und die Sprachen, die von PDAs akzeptiert werden, sind dieselbe Sprachklasse.</p>
<p><strong>Satz:</strong> Eine von einem DPDA akzeptierteSprache hat eine eindeutige Grammatik.</p>
<p>Vorgehensweise im Compilerbau: Eine Grammatik für die gewünschte Sprache definieren und schauen, ob sich daraus ein DPDA generieren lässt (automatisch).</p>
<h1 id="syntaxanalyse">Syntaxanalyse</h1>
<h2 id="was-brauchen-wir-für-die-syntaxanalyse-von-programmen">Was brauchen wir für die Syntaxanalyse von Programmen?</h2>
<ul>
<li>
<p>einen Grammatiktypen, aus dem sich manuell oder automatisiert ein Programm zur deterministischen Syntaxanalyse (=Parser) erstellen lässt</p>
</li>
<li>
<p>einen Algorithmus zum Parsen von Programmen mit Hilfe einer solchen Grammatik</p>
</li>
</ul>
<h2 id="syntax">Syntax</h2>
<p>Wir verstehen unter Syntax eine Menge von Regeln, die die Struktur von Daten (z. B. Programmen) bestimmen.</p>
<p>Diese vorgegebene Syntax wird im Compilerbau mit einer kontextfreien Grammatik beschrieben und mit einem sogenannten <strong>Parser</strong> analysiert.</p>
<p>Heute: LL-Parsing, mit dem man eine Teilmenge der eindeutigen kontextfreien Grammatiken syntaktich analysieren kann.</p>
<p>Dabei wird der Ableitungsbaum von oben nach unten aufgebaut.</p>
<h2 id="ziele-der-syntaxanalyse">Ziele der Syntaxanalyse</h2>
<ul>
<li>
<p>Bestimmung der syntaktischen Struktur eines Programms</p>
</li>
<li>
<p>aussagekräftige Fehlermeldungen, wenn ein Eingabeprogramm syntaktisch nicht korrekt ist</p>
</li>
<li>
<p>Erstellung des AST (abstrakter Syntaxbaum): Der Parse Tree ohne Symbole, die nach der Syntaxanalyse inhaltlich irrelevant sind (z. B. Semikolons, manche Schlüsselwörter)</p>
</li>
<li>
<p>die Symboltablelle(n) mit Informationen bzgl. Bezeichner (Variable, Funktionen und Methoden, Klassen, benutzerdefinierte Typen, Parameter, ...), aber auch die Gültigkeitsbereiche.</p>
</li>
</ul>
<h1 id="llk-grammatiken">LL(k)-Grammatiken</h1>
<h2 id="first-mengen">First-Mengen</h2>
<span class="math align-center">$S \rightarrow A \ \vert \ B \ \vert \ C$</span>
<p>Welche Produktion nehmen?</p>
<p>Wir brauchen die &quot;terminalen k-Anfänge&quot; von Ableitungen von Nichtterminalen, um eindeutig die nächste zu benutzende Produktion festzulegen. <span class="math align-center">$k$</span> ist dabei die Anzahl der Vorschautoken.</p>
<p><strong>Def.:</strong> Wir definieren <span class="math align-center">$First$</span> - Mengen einer Grammatik wie folgt:</p>
<ul>
<li><span class="math align-center">$a \in T^\ast, |a| \leq k: {First}_k (a) = \lbrace a \rbrace$</span></li>
<li><span class="math align-center">$a \in T^\ast, |a| > k: {First}_k (a) = \lbrace v \in T^\ast \mid a = vw, |v| = k \rbrace$</span></li>
<li><span class="math align-center">$\alpha \in (N \cup T)^\ast \backslash T^\ast: {First}_k (\alpha) = \lbrace v \in T^\ast \mid  \alpha \overset{\ast}{\Rightarrow} w,\text{mit}\ w \in T^\ast, First_k(w) = \lbrace v \rbrace \rbrace$</span></li>
</ul>
<h2 id="linksableitungen">Linksableitungen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik <span class="math align-center">$G$</span> ist die <em>Linksableitung</em> von <span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erhält, wenn in jedem Schritt das am weitesten links stehende Nichtterminal in <span class="math align-center">$\alpha$</span> abgeleitet wird.</p>
<p>Man schreibt <span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_l \beta.$</span></p>
<h2 id="llk-grammatiken-1">LL(k)-Grammatiken</h2>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik <span class="math align-center">$G = (N, T, P, S)$</span> ist genau dann eine <em>LL(k)</em>-Grammatik, wenn für alle Linksableitungen der Form:</p>
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l\ wA \gamma\ {\Rightarrow}_l\ w\alpha\gamma \overset{\ast}{\Rightarrow}_l wx$</span>
<p>und</p>
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l wA \gamma {\Rightarrow}_l w\beta\gamma \overset{\ast}{\Rightarrow}_l wy$</span>
<p>mit <span class="math align-center">$(w, x, y \in T^\ast, \alpha, \beta, \gamma \in (N \cup T)^\ast, A \in N)$</span> und <span class="math align-center">$First_k(x) = First_k(y)$</span>
gilt:</p>
<span class="math align-center">$\alpha = \beta$</span>
<h2 id="ll1-grammatiken">LL(1)-Grammatiken</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="llk-sprachen">LL(k)-Sprachen</h2>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der deterministisch parsbaren Sprachen.</p>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der von <em>LL(k+1)</em>-Grammatiken erzeugten Sprachen.</p>
<p>Für eine kontextfreie Grammatik <span class="math align-center">$G$</span> ist nicht entscheidbar, ob es eine <em>LL(1)</em> - Grammatik <span class="math align-center">$G'$</span> gibt mit <span class="math align-center">$L(G) = L(G')$</span>.</p>
<p>In der Praxis reichen <em>LL(1)</em> - Grammatiken oft. Hier gibt es effiziente Parsergeneratoren (hier: ANTLR), deren Eingabe eine LL-Grammatik ist, und die als Ausgabe den Quellcode eines (effizienten) tabellengesteuerten Parsers generieren.</p>
<h2 id="was-brauchen-wir-zur-erzeugung-eines-llk-parsers">Was brauchen wir zur Erzeugung eines LL(k)-Parsers?</h2>
<ul>
<li>eine <em>LL(k)</em>-Grammatik</li>
<li>die <span class="math align-center">$First_k$</span>-Mengen der rechten Seiten aller Produktionsregeln</li>
<li>die <span class="math align-center">$Follow_k$</span>-Mengen aller Nichtterminale und der rechten Seiten aller Produktionsregeln</li>
<li>das Endezeichen <span class="math align-center">$\perp$</span> hinter dem Eingabewort</li>
</ul>
<p><strong>Def.:</strong> Wir definieren <span class="math align-center">$Follow$</span> - Mengen einer Grammatik wie folgt:</p>
<span class="math align-center">$Follow_k(\beta) = \lbrace w \in T^\ast\ |\ \exists \alpha, \gamma \in (N \cup T)^\ast\ \text{mit}\ S \overset{\ast}{\Rightarrow}_l\ \alpha \beta \gamma\ \text{und}\ w \in First_k(\gamma) \rbrace$</span>
<h2 id="beispiel-first--und-follow-mengen">Beispiel: First- und Follow-Mengen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-konstruktion-einer-ll-parsertabelle" class="fragile">Algorithmus: Konstruktion einer LL-Parsertabelle</h2>
<p><strong>Eingabe:</strong> Eine Grammatik <span class="math align-center">$G = (N, T, P, S)$</span></p>
<p><strong>Ausgabe:</strong> Eine Parsertabelle <span class="math align-center">$P$</span></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg/LL-Parsertabelle.png" alt="Algorithmus zur Generierung einer LL-Parsertabelle" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Generierung einer LL-Parsertabelle</p></figcaption>
</figure>
<p>Statt <span class="math align-center">$First_1(\alpha)$</span> wird oft nur <span class="math align-center">$First(\alpha)$</span> geschrieben.</p>
<h2 id="beispiel-ll-parsertabellen">Beispiel: LL-Parsertabellen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="ll-parser">LL-Parser</h2>
<p>Rekursive Programmierung bedeutet, dass das Laufzeitsystem einen Stack benutzt. Diesen Stack kann man auch &quot;selbst programmieren&quot;, d. h. einen PDA implementieren. Dabei wird ebenfalls die oben genannte Tabelle zur Bestimmung der nächsten anzuwendenden Produktion benutzt. Der Stack enthält die zu erwartenden Eingabezeichen, wenn immer eine Linksableitung gebildet wird. Diese Zeichen im Stack werden mit dem Input gematcht.</p>
<h2 id="algorithmus-tabellengesteuertes-ll-parsen-mit-einem-pda" class="fragile">Algorithmus: Tabellengesteuertes LL-Parsen mit einem PDA</h2>
<p><strong>Eingabe:</strong> Eine Grammatik <span class="math align-center">$G = (N, T, P, S)$</span>, eine Parsertabelle <span class="math align-center">$P$</span> mit &quot;<span class="math align-center">$w\perp$</span>&quot; als initialem Kellerinhalt</p>
<p><strong>Ausgabe:</strong> Wenn <span class="math align-center">$w \in L(G)$</span>, eine Linksableitung von <span class="math align-center">$w$</span>, Fehler sonst</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/cfg/LL-Parser.png" alt="Algorithmus zum tabellengesteuerten LL-Parsen" width="49%" height="auto">
    <figcaption><p>Algorithmus zum tabellengesteuerten LL-Parsen</p></figcaption>
</figure>
<h2 id="beispiel-ll-parsen">Beispiel: LL-Parsen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="ergebnisse-der-syntaxanalyse">Ergebnisse der Syntaxanalyse</h2>
<ul>
<li>
<p>eventuelle Syntaxfehler mit Angabe der Fehlerart und des -Ortes</p>
</li>
<li>
<p>Format für die Weiterverarbeitung:</p>
<ul>
<li>Ableitungsbaum oder Syntaxbaum oder Parse Tree</li>
<li>abstrakter Syntaxbaum (AST): Der Parse Tree ohne Symbole, die nach der Syntaxanalyse inhaltlich irrelevant sind (z. B. ;, Klammern, manche Schlüsselwörter, <span class="math align-center">$\ldots$</span>)</li>
</ul>
</li>
</ul>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="das-sollen-sie-mitnehmen">Das sollen Sie mitnehmen</h2>
<ul>
<li>Die Struktur von gängigen Programmiersprachen lässt sich nicht mit regulären Ausdrücken beschreiben und damit nicht mit DFAs akzeptieren.</li>
<li>Das Automatenmodell der DFAs wird um einen endlosen Stack erweitert, das ergibt PDAs.</li>
<li>Kontextfreie Grammatiken (CFGs) erweitern die regulären Grammatiken.</li>
<li>Deterministisch parsebare Sprachen haben eine eindeutige kontextfreie Grammatik.</li>
<li>Es ist nicht entscheidbar, ob eine gegebene kontextfreie Grammatik eindeutig ist.</li>
<li>Syntaxanalyse wird mit deterministisch kontextfreien Grammatiken durchgeführt.</li>
<li>Eine Teilmenge der dazu gehörigen Sprachen lässt sich top-down parsen.</li>
<li>Ein effizienter LL(k)-Parser realisiert einen DPDA und kann automatisch aus einer LL(k)-Grammatik generiert werden.</li>
<li>Der Parser liefert in der Regel einen abstrakten Syntaxbaum.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Aho2023'>[Aho2023] <a href='https://learning.oreilly.com/library/view/compilers-principles-techniques/9789357054881/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Compilers: Principles, Techniques, and Tools, Updated 2nd Edition by Pearson</strong></a><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D. und Bansal, S., Pearson India, 2023. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-9-3570-5488-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-9-3570-5488-1</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul>
  </div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K1) PDAs</li> <li>(K1) Deterministische PDAs</li> <li>(K1) Kontextfreie Grammatiken</li> <li>(K1) Deterministisch kontextfreie Grammatiken</li> <li>(K1) Top-Down-Analyse</li> <li>(K1) LL-Parser</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li></ul>
  </div>
</div>



    







<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Parser mit ANTLR generieren</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Mit ANTLR kann aus einer Grammatik ein LL(*)-Parser generiert werden. Die Parser-Regeln
in der Grammatik fangen dabei mit einem <strong>Kleinbuchstaben</strong> an (Erinnerung: Lexer-Regel
starten mit einem Großbuchstaben).</p>
<p>Regeln haben einen Namen (linke Seite) und eine Produktion (rechte Seite). Dabei
können beliebige Abfolgen von Lexer- und Parser-Regeln auf der rechten Seite
einer Parser-Regel auftauchen. Die Token müssen jeweils matchen, die Parser-Regeln
werden in einen Aufruf der jeweiligen generierten Funktion übersetzt.</p>
<p>Parser-Regeln können aus mehreren Alternativen bestehen, diese werden per <code>|</code> separiert.
Dabei hat bei Mehrdeutigkeiten die erste passende Alternative Vorrang. Wie bei Lexer-Regeln
können Teile per <code>?</code> ein- oder keinmal vorkommen, per <code>*</code> beliebig oft oder per <code>+</code> ein-
oder mehrfach.</p>
<p>ANTLR erlaubt im Gegensatz zu allgemeinen LL-Parsern direkte Links-Rekursion. (Indirekte
Links-Rekursion funktioniert allerdings nicht.)</p>
<p>Der von ANTLR generierte Parser erzeugt auf der Eingabe einen Parse-Tree, der die Strukturen
der Grammatik widerspiegelt: Die Token bilden die Blätter und jede erfolgreich durchlaufene
Parser-Regel bildet einen entsprechenden Knoten im Baum.</p>
<p>Für die Traversierung des Parse-Tree kann man die generierten Listener- oder Visitor-Klassen
nutzen. Beim Einsatz der Listener nutzt man die vorgegebene Klasse <code>ParseTreeWalker</code>, die
mit dem Parse-Tree und dem Listener den Baum per Tiefensuche traversiert und immer die
jeweiligen <code>enterRegel</code>- und <code>exitRegel</code>-Methoden aufruft. Beim Visitor muss die Traversierung
selbst erledigt werden, hier steht die aus der Klassenhierarchie geerbte Methode <code>visit</code>
als Startpunkt zur Verfügung. In dieser Methode wird basierend auf dem Knotentyp die in den
Visitor-Klassen implementierte <code>visitRegel</code>-Methode aufgerufen und man muss darauf achten,
die Kindknoten durch passende Aufrufe zu traversieren. Sowohl bei den generierten Listener-
als auch den Visitor-Klassen kann man die leeren Defaultmethoden bei Bedarf selbst überschreiben.
Für den Zugriff auf die Regel-Elemente werden die sogenannten Kontextobjekte als Parameter
übergeben.</p>
<p>Benannte Alternativen und Regel-Elemente sind nützlich, weil für die benannten Alternativen
zusätzliche Kontextklassen erzeugt werden, über die dann auf die Bestandteile der Alternativen
zugegriffen werden kann. Außerdem werden zusätzlich passende <code>enterAlternative</code>- und <code>exitAlternative</code>-
bzw. <code>visitAlternative</code>-Methoden generiert. Für benannte Regel-Elemente wird ein entsprechend
benanntes Attribut im Kontextobjekt angelegt, welches <code>public</code> sichtbar ist.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/YuUHBvPUS4k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li> <li><a href='https://youtu.be/FJOEPY-TMmw' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Parser</a></li></ul>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/medienportal/m/19925b756d6fc934bfe0b5107eb5fa58373a53af49c690ebce86e15f2b212c89c80ea7665e42c78abdc8dfe0718ea46f6a9817eeba4ad1293bdb4c84f7c8f084' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li></ul>
  </div>
</div>




    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K2) Aufbau der Parser-Regeln</li> <li>(K3) Alternativen und optionale/mehrfache Regelteile in Parser-Regeln</li> <li>(K3) Vorrang von Alternativen (bei Mehrdeutigkeiten)</li> <li>(K3) Benannte Alternativen und Regel-Elemente</li> <li>(K2) Aufbau des Parse-Tree</li> <li>(K3) Umgang mit Kontext-Objekten</li> <li>(K3) Traversierung des Parse-Tree mit den generierten Listenern oder Visitors</li></ul>
  </div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start : stmt<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ID    : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>NUM   : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WS    : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/02-parsing/src/Hello.g4" target="_blank"><span class="title">Konsole: Hello (grun, Parse-Tree)</span></a></span></div>
<h3 id="starten-des-parsers">Starten des Parsers</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Parser ausführen:
<ul>
<li>
<p><code>grun Hello start -tree</code> oder <code>grun Hello start -gui</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CharStreams;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CommonTokenStream;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.tree.ParseTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        HelloLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer(CharStreams.<span style="color:#a6e22e">fromStream</span>(System.<span style="color:#a6e22e">in</span>));
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream(lexer);
</span></span><span style="display:flex;"><span>        HelloParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloParser(tokens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser.<span style="color:#a6e22e">start</span>();  <span style="color:#75715e">// Start-Regel</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(tree.<span style="color:#a6e22e">toStringTree</span>(parser));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</li>
</ul>
</li>
</ol>
<h3 id="startregeln">Startregeln</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Alle Regeln mit kleinem Anfangsbuchstaben sind Parser-Regeln</li>
<li>Alle Regeln mit großem Anfangsbuchstaben sind Lexer-Regeln</li>
</ul>
<h3 id="formen-der-subregeln">Formen der Subregeln</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div>
<p>Um die Regel <code>stmt</code> anwenden zu können, müssen alle Elemente auf der rechten
Seite der Regel erfüllt werden. Dabei müssen die Token wie <code>ID</code>, <code>=</code> und <code>;</code>
matchen und die Subregel <code>expr</code> muss erfüllt werden können. Beachten Sie das
abschließende Semikolon am Ende einer ANTLR-Regel!</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div>
<p>Alternativen werden durch ein <code>|</code> getrennt. Hier muss genau eine Alternative
erfüllt werden. Falls nötig, trennt man die Alternativen durch Einschließung
in runden Klammern vom Rest der Regel ab: <code>r : a (b | c) d ;</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;</span></span></code></pre></div>
<p>Der durch den <code>*</code> gekennzeichnete Teil kann beliebig oft vorkommen oder auch
fehlen. Bei einem <code>+</code> müsste der Teil mind. einmal vorkommen und bei einem
<code>?</code> entsprechend einmal oder keinmal.</p>
<p>Auch hier kann man die Operatoren durch ein zusätzliches <code>?</code> auf non-greedy
umschalten (analog zu den Lexer-Regeln).</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#subrules" rel="external" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h3 id="reihenfolge-in-grammatik-definiert-priorität">Reihenfolge in Grammatik definiert Priorität</h3>
<p>Falls mehr als eine Parser-Regel die selbe Input-Sequenz matcht, löst ANTLR
diese Mehrdeutigkeit auf, indem es die erste Alternative nimmt, die an der
Entscheidung beteiligt ist.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>  ;
</span></span><span style="display:flex;"><span>expr  : <span style="color:#66d9ef">ID</span>   <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;</span></span></code></pre></div>
<p>Bei der Eingabe &quot;foo&quot; würde die Alternative <code>ID</code> in der Regel <code>expr</code> &quot;gewinnen&quot;,
weil sie in der Grammatik vor der Alternative <code>ID</code> in der Regel <code>stmt</code> kommt und
damit Vorrang hat.</p>
<h3 id="parse-tree">Parse-Tree</h3>
<p>Betrachten wir erneut die obige Grammatik.</p>
<p>Die Eingabe von &quot;<code>a = 42;</code>&quot; führt zu folgendem Parse-Tree:</p>
<p><a href="#R-image-6243093ba2f3986266bbb0132a657bd9" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/hello_ex1.png?width=60%25&height=auto" style=" height: auto; width: 60%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6243093ba2f3986266bbb0132a657bd9"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/hello_ex1.png?width=60%25&height=auto"></a></p>
<p>Diese Eingabe führt zur Erkennung der Token <code>[ID, WS, =, WS, NUM, ;]</code>, wobei die
<code>WS</code>-Token verworfen werden und der Parser den Tokenstream <code>[ID, =, NUM, ;]</code>
erhält.</p>
<p>Die Startregel hat auf der rechten Seite kein oder mehrere <code>stmt</code>-Regeln. Die
<code>stmt</code>-Regel fordert auf der rechten Seite entweder die Token <code>ID</code>und <code>=</code> sowie
die Regel <code>expr</code> gefolgt vom Token <code>;</code>, oder die Regel <code>expr</code> gefolgt vom Token
<code>;</code>. In unserem Beispiel kann für das &quot;a&quot; das Token <code>ID</code> produziert werden, das
&quot;=&quot; matcht ebenfalls. Die &quot;42&quot; wird erklärt, indem für <code>expr</code> ein <code>term</code> und
dort ein <code>atom</code> aufgerufen wird. Für das <code>atom</code> muss entweder ein Token <code>ID</code>
oder <code>NUM</code> als nächstes Token kommen - hier wird die &quot;42&quot; wird als Token <code>NUM</code>
verarbeitet. Da die weiteren Regelteile in <code>term</code> und <code>expr</code> optional sind,
haben wir damit ein <code>expr</code> erfüllt und das nachfolgende <code>;</code>-Token schließt die
erste Alternative der Regel <code>stmt</code> erfolgreich ab.</p>
<p>Im entstehenden Parse-Tree sind diese Abläufe und grammatikalischen Strukturen
direkt erkennbar. Jede erfolgreich durchlaufene Parserregel wird zu einem
Knoten im Parse-Tree. Die Token werden als Terminale (Blätter) in den Baum
eingehängt.</p>
<p><em>Anmerkung</em>: Der Parse-Tree ist das Ergebnis der Parsers-Phase im Compiler und
dient damit als Input für die folgenden Compilerstufen. In der Regel benötigt
man die oft recht komplexen Strukturen aber später nicht mehr und vereinfacht
den Baum zu einem <em>Abstract Syntax Tree</em> (AST). Im Beispiel könnte man den Zweig
<code>stmt - expr - term - atom - 42</code> zu <code>stmt - 42</code> vereinfachen.</p>
<p>Betrachten wir nun die Eingabe <code>foo = 2+3*4; bar = 3*4+2;</code>. Diese führt zu
folgendem Parse-Tree:</p>
<p><a href="#R-image-a0c4c87c1027b1b0d38e7cb0d6770b35" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/hello_ex2.png?width=60%25&height=auto" style=" height: auto; width: 60%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0c4c87c1027b1b0d38e7cb0d6770b35"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/hello_ex2.png?width=60%25&height=auto"></a></p>
<p>Wie man sehen kann, sind in der Grammatik die üblichen Vorrangregeln für die
Operationen <code>+</code> und <code>*</code> berücksichtigt - die Multiplikation wird in beiden
Fällen korrekt &quot;unter&quot; der Addition im Baum eingehängt.</p>
<h3 id="to-eof-not-to-eof">To EOF not to EOF?</h3>
<p>Startregeln müssen nicht unbedingt den gesamten Input &quot;konsumieren&quot;. Sie müssen
per Default nur eine der Alternativen in der Startregel erfüllen.</p>
<p>Betrachten wir noch einmal einen leicht modifizierten Ausschnitt aus der obigen
Grammatik:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;</span></span></code></pre></div>
<p>Die Startregel wurde so geändert, dass sie nur noch genau ein Statement
akzeptieren soll.</p>
<p>In diesem Fall würde die Startregel bei der Eingabe &quot;aa; bb;&quot; nur den ersten
Teil &quot;aa;&quot; konsumieren (als Token <code>ID</code>) und das folgende &quot;bb;&quot; ignorieren.
Das wäre in diesem Fall aber auch kein Fehler.</p>
<p>Wenn der gesamte Eingabestrom durch die Startregel erklärt werden soll,
dann muss das vordefinierte Token <code>EOF</code> am Ende der Startregel eingesetzt
werden:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt <span style="color:#66d9ef">EOF</span>;</span></span></code></pre></div>
<p>Hier würde die Eingabe &quot;aa; bb;&quot; zu einem Fehler führen, da nur der Teil &quot;aa;&quot;
durch die Startregel abgedeckt ist (Token <code>ID</code>), und der Rest &quot;bb;&quot; zwar sogar
ein gültiges Token wären (ebenfalls <code>ID</code> und <code>;</code>), aber eben nicht mehr von der
Startregel akzeptiert. Durch das <code>EOF</code> soll die Startregel aber den gesamten
Input konsumieren und erklären, was hier nicht geht und entsprechend zum Fehler
führt.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#start-rules-and-eof" rel="external" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h2 id="expressions-und-vorrang-operatoren">Expressions und Vorrang (Operatoren)</h2>
<p>Betrachten wir noch einmal den Ausschnitt für die Ausdrücke (<em>Expressions</em>) in
der obigen Beispielgrammatik:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div>
<p>Diese typische, etwas komplex anmutende Struktur soll sicher stellen, dass die
Vorrangregeln für Addition und Multiplikation korrekt beachtet werden, d.h. dass
<code>2+3*4</code> als <code>2+(3*4)</code> geparst wird und nicht fälschlicherweise als <code>(2+3)*4</code>
erkannt wird.</p>
<p>Zusätzlich muss bei LL-Parsern Links-Rekursion vermieden werden: Die Parser-Regeln
werden in Funktionsaufrufe übersetzt, d.h. bei einer Links-Rekursion würde man die
selbe Regel immer wieder aufrufen, ohne ein Token aus dem Token-Strom zu entnehmen.</p>
<p>ANTLR (ab Version 4) kann mit beiden Aspekten automatisch umgehen:</p>
<ul>
<li>ANTLR kann direkte Linksrekursion automatisch auflösen. Die Regel <code>r : r T U | V ;</code>
kann also in ANTLR verarbeitet werden.</li>
<li>ANTLR besitzt einen Mechanismus zur Auflösung von Mehrdeutigkeiten. Wie oben
geschrieben, wird bei der Anwendbarkeit von mehreren Alternativen die erste
Alternative genutzt.</li>
</ul>
<p>Damit lässt sich die typische Struktur für Expression-Grammatiken deutlich lesbarer
gestalten:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div>
<p>Die Regel <code>expr</code> ist links-rekursiv, was normalerweise bei LL-Parsern problematisch
ist. ANTLR löst diese Links-Rekursion automatisch auf (vgl.
<a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" rel="external" target="_blank">github.com/antlr/antlr4/blob/master/doc/left-recursion.md</a>).</p>
<p>Da bei Mehrdeutigkeit in der Grammatik, also bei der Anwendbarkeit mehrerer Alternativen
stets die erste Alternative genommen wird, lassen sich die Vorrangregeln durch die
Reihenfolge der Alternativen in der <code>expr</code>-Regel implementieren: Die Multiplikation
hat Vorrang von der Addition, und diese hat wiederum Vorrang von einer einfachen <code>ID</code>.</p>
<h3 id="direkte-vs-indirekte-links-rekursion">Direkte vs. indirekte Links-Rekursion</h3>
<p>ANTLR kann nur <em>direkte</em> Links-Rekursion auflösen. Regeln wie <code>r : r T U | V ;</code> stellen
in ANTLR also kein Problem dar.</p>
<p><em>Indirekte</em> Links-Rekursion erkennt ANTLR dagegen nicht:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : s <span style="color:#66d9ef">T</span> <span style="color:#66d9ef">U</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">V</span> ;
</span></span><span style="display:flex;"><span>s : r <span style="color:#66d9ef">W</span> <span style="color:#66d9ef">X</span> ;</span></span></code></pre></div>
<p>Hier würden sich die Regeln <code>r</code> und <code>s</code> gegenseitig aufrufen und kein Token aus dem
Tokenstrom entfernen, so dass der generierte LL-Parser hier in einer Endlosschleife
stecken bleiben würde. Mit indirekter Links-Rekursion kann ANTLR nicht umgehen.</p>
<h3 id="konflikte-in-regeln">Konflikte in Regeln</h3>
<p>Wenn mehrere Alternativen einer Regel anwendbar sind, entscheidet sich ANTLR für die
erste Alternative.</p>
<p>Wenn sich mehrere Tokenregeln überlappen, &quot;gewinnt&quot; auch hier die zuerst definierte
Regel.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;</span></span></code></pre></div>
<p>Hier werden ein implizites Token <code>'func'</code> sowie die expliziten Token <code>FOR</code> und <code>ID</code>
definiert. Dabei sind die Lexeme für <code>'func'</code> und <code>FOR</code> auch in <code>ID</code> enthalten.
Dennoch werden <code>'func'</code> und <code>FOR</code> erkannt und nicht über <code>ID</code> gematcht, weil sie
<em>vor</em> der Regel <code>ID</code> definiert sind.</p>
<p>Tatsächlich sortiert ANTLR die Regeln intern um, so dass alle Parser-Regeln <em>vor</em> den
Lexer-Regeln definiert sind. Die impliziten Token werden dabei noch vor den expliziten
Token-Regeln angeordnet. Im obigen Beispiel hat also <code>'func'</code> eine höhere Priorität
als <code>FOR</code>, und <code>FOR</code> hat eine höhere Priorität als <code>ID</code>. Aus diesem Grund gibt es die
Konvention, die Parser-Regeln in der Grammatik vor den Lexer-Regeln zu definieren - dies
entspricht quasi der Anordnung, die ANTLR bei der Verarbeitung sowieso erzeugen würde.</p>
<p>Aus diesem Grund würde auch eine Umsortierung der obigen Grammatik funktionieren:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;</span></span></code></pre></div>
<p>Intern würde ANTLR die Parser-Regel <code>def</code> wieder vor den beiden Lexer-Regeln anordnen,
und zwischen den Parser-Regeln und den Lexer-Regeln die impliziten Token (hier <code>'func'</code>).</p>
<h2 id="kontext-objekte-für-parser-regeln">Kontext-Objekte für Parser-Regeln</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();}
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div>
<p><a href="#R-image-886da70dc03d31acb9d94a28dd12ba64" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParserRuleContext.png?width=80%25&height=auto" style=" height: auto; width: 80%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-886da70dc03d31acb9d94a28dd12ba64"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParserRuleContext.png?width=80%25&height=auto"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zurück. Darüber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr</code> liefert ein <code>ExprContext</code>-Objekt zurück.</p>
<p>In der Aktion fragt man das Kontextobjekt über <code>ctx</code> ab, in den Listener-
und Visitor-Methoden erhält man die Kontextobjekte als Parameter.</p>
<p>Für einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zurück.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann <em>Felder</em> für die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe nächste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h2 id="benannte-regel-elemente-oder-alternativen">Benannte Regel-Elemente oder Alternativen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext { ... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span>() { ... }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext { ... }</span></span></code></pre></div>
<p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man für den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird für die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h2 id="arbeiten-mit-antlr-listeners">Arbeiten mit ANTLR-Listeners</h2>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;für sich&quot; halten, d.h. unabhängig von einer
konkreten Zielsprache und die Aktionen über die Listener (oder Visitors, s.u.)
ausführen.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div>
<p>ANTLR kann zu dieser Grammatik <code>calc.g4</code> einen passenden Listener (Interface
<code>calcListener</code>) generieren (Option <code>-listener</code> beim Aufruf von <code>antlr</code>).
Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse <code>calcBaseListener</code>):</p>
<p><a href="#R-image-4b1ed13aa0f1fc1ca01aef777451e70d" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParseTreeListener.png?width=80%25&height=auto" style=" height: auto; width: 80%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4b1ed13aa0f1fc1ca01aef777451e70d"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParseTreeListener.png?width=80%25&height=auto"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man benötigt.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span>(calcParser.<span style="color:#a6e22e">MULTContext</span> ctx) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span>(calcParser.<span style="color:#a6e22e">ADDContext</span> ctx) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span>(calcParser.<span style="color:#a6e22e">ZAHLContext</span> ctx) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Anschließend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer(CharStreams.<span style="color:#a6e22e">fromStream</span>(System.<span style="color:#a6e22e">in</span>));
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream(lexer);
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser(tokens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser.<span style="color:#a6e22e">s</span>();    <span style="color:#75715e">// Start-Regel</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker();
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener();
</span></span><span style="display:flex;"><span>        walker.<span style="color:#a6e22e">walk</span>(eval, tree);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/02-parsing/src/TestMyListener.java" target="_blank"><span class="title">Beispiel: TestMyListener.java und calc.g4</span></a></span></div>
<h2 id="arbeiten-mit-dem-visitor-pattern">Arbeiten mit dem Visitor-Pattern</h2>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung).</p>
<p>Hier muss man im Gegensatz zu den Listeners allerdings selbst für eine geeignete
Traversierung des Parse-Trees sorgen. Dafür hat man mehr Freiheiten im Vergleich
zum Einsatz von Listeners, insbesondere im Hinblick auf Rückgabewerte.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div>
<p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren (Option <code>-visitor</code> beim Aufruf von <code>antlr</code>). Weiterhin generiert ANTLR
eine leere Basisimplementierung (Klasse <code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-edb013aa509e94cd96f908589d0c6022" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&height=auto" style=" height: auto; width: 80%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edb013aa509e94cd96f908589d0c6022"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/02-parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&height=auto"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und überschreibt
die Methoden, die man benötigt. Wichtig ist, dass man selbst für das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span>(calcParser.<span style="color:#a6e22e">MULTContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span>(calcParser.<span style="color:#a6e22e">ADDContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span>(calcParser.<span style="color:#a6e22e">ZAHLContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Anschließend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer(CharStreams.<span style="color:#a6e22e">fromStream</span>(System.<span style="color:#a6e22e">in</span>));
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream(lexer);
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser(tokens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser.<span style="color:#a6e22e">s</span>();    <span style="color:#75715e">// Start-Regel</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor();
</span></span><span style="display:flex;"><span>        eval.<span style="color:#a6e22e">visit</span>(tree);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/02-parsing/src/TestMyVisitor.java" target="_blank"><span class="title">Beispiel: TestMyVisitor.java und calc.g4</span></a></span></div>
<h2 id="eingebettete-aktionen-und-attribute">Eingebettete Aktionen und Attribute</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s   : expr                      {System.err.println($expr.v);}
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>    : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr       {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>    ;</span></span></code></pre></div>
<p>Auch die Parser-Regeln können mit eingebetteten Aktionen ergänzt werden, die
in die (für die jeweilige Regel) generierte Methode eingefügt werden und bei
erfolgreicher Anwendung der Parser-Regel ausgeführt werden.</p>
<p>Über <code>returns [int v]</code> fügt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer)
hinzu, welches man im jeweiligen Kontext abfragen bzw. setzen kann (agiert
als Rückgabewert der generierten Methode). Auf diesen Wert kann in den
Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p><em>Anmerkung</em>: Durch den Einsatz von eingebetteten Aktionen und Attributen wird
die Grammatik abhängig von der Zielsprache des generierten Lexers/Parsers!</p>
<h2 id="ausblick">Ausblick</h2>
<p>Damit haben wir die sprichwörtliche &quot;Spitze des Eisbergs&quot; gesehen. Mit ANTLR
sind noch viele weitere Dinge möglich. Bitte nutzen Sie aktiv die Dokumentation
auf <a href="https://github.com/antlr/antlr4" rel="external" target="_blank">github.com/antlr/antlr4</a>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Parser mit ANTLR generieren: Parser-Regeln werden mit <strong>Kleinbuchstaben</strong> geschrieben</p>
<ul>
<li>Regeln können Lexer- und Parser-Regeln &quot;aufrufen&quot;</li>
<li>Regeln können Alternativen haben</li>
<li>Bei Mehrdeutigkeit: Vorrang für erste Alternative</li>
<li>ANTLR erlaubt direkte Links-Rekursion</li>
<li>ANTLR erzeugt Parse-Tree</li>
<li>Benannte Alternativen und Regel-Elemente</li>
<li>Traversierung des Parse-Tree: Listener oder Visitoren, Zugriff auf Kontextobjekte</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p><strong>Lexer und Parser mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" rel="external" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer+Parser mit ANTLR.
Implementieren Sie mit Hilfe des Parse-Trees und der Listener oder Visitoren einen einfachen Pretty-Printer.</p>
<p>(Die genauere Sprachdefinition finden Sie bei Bedarf unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" rel="external" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.)</p>
  </div>
</div>



    




    
    
        
        
        

        
            
            
            
        
    
    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-laptop-code"></i> Übungsblätter/Aufgaben
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1360443/homework/sheet01.html' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Blatt 01: Reguläre Sprachen</a></li></ul>
  </div>
</div>



    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Parr2014'>[Parr2014] <a href='https://learning.oreilly.com/library/view/the-definitive-antlr/9781941222621/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>The Definitive ANTLR 4 Reference</strong></a><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
        </div>
      </main>
    </div>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/clipboard.min.js?1739788418" defer></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/perfect-scrollbar.min.js?1739788418" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/mathjax/tex-mml-chtml.js?1739788418"></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1360443/js/theme.js?1739788418" defer></script>
  </body>
</html>
